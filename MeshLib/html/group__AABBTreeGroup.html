<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.7"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MeshLib: AABB Tree overview</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="CustomStyle.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="favicon.ico"/></td>
  <td id="projectalign">
   <div id="projectname">MeshLib
   </div>
  </td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.7 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('group__AABBTreeGroup.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">AABB Tree overview</div></div>
</div><!--header-->
<div class="contents">

<p>This chapter represents documentation about AABB Tree.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMR_1_1Cuda_1_1FastWindingNumber.html">MR::Cuda::FastWindingNumber</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMR_1_1AABBTree.html">MR::AABBTree</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structMR_1_1BoxedLeaf.html">MR::BoxedLeaf&lt; T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structMR_1_1ABBTreeTraits.html">MR::ABBTreeTraits&lt; L, B &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structMR_1_1AABBTreeNode.html">MR::AABBTreeNode&lt; T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMR_1_1AABBTreePoints.html">MR::AABBTreePoints</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">bounding volume hierarchy for point cloud structure  <a href="classMR_1_1AABBTreePoints.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structMR_1_1PolylineTraits.html">MR::PolylineTraits&lt; V &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structMR_1_1PolylineTraits_3_01Vector2f_01_4.html">MR::PolylineTraits&lt; Vector2f &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structMR_1_1PolylineTraits_3_01Vector3f_01_4.html">MR::PolylineTraits&lt; Vector3f &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMR_1_1AABBTreePolyline.html">MR::AABBTreePolyline&lt; V &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">bounding volume hierarchy for line segments  <a href="classMR_1_1AABBTreePolyline.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structMR_1_1FaceFace.html">MR::FaceFace</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structMR_1_1UndirectedEdgeUndirectedEdge.html">MR::UndirectedEdgeUndirectedEdge</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMR_1_1FastWindingNumber.html">MR::FastWindingNumber</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structMR_1_1IntersectionPrecomputes.html">MR::IntersectionPrecomputes&lt; T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structMR_1_1IntersectionPrecomputes2.html">MR::IntersectionPrecomputes2&lt; T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structMR_1_1EdgeTri.html">MR::EdgeTri</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">edge from one mesh and triangle from another mesh  <a href="structMR_1_1EdgeTri.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structMR_1_1PreciseCollisionResult.html">MR::PreciseCollisionResult</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structMR_1_1CoordinateConverters.html">MR::CoordinateConverters</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">this struct contains coordinate converters float-int-float  <a href="structMR_1_1CoordinateConverters.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structMR_1_1MeshDistanceResult.html">MR::MeshDistanceResult</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structMR_1_1MeshSignedDistanceResult.html">MR::MeshSignedDistanceResult</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structMR_1_1MeshIntersectionResult.html">MR::MeshIntersectionResult</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structMR_1_1MultiMeshIntersectionResult.html">MR::MultiMeshIntersectionResult</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structMR_1_1Line3Mesh.html">MR::Line3Mesh&lt; T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structMR_1_1MeshProjectionResult.html">MR::MeshProjectionResult</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structMR_1_1SignedDistanceToMeshResult.html">MR::SignedDistanceToMeshResult</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structMR_1_1PointsProjectionResult.html">MR::PointsProjectionResult</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structMR_1_1PolylineProjectionResult.html">MR::PolylineProjectionResult&lt; V &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structMR_1_1PolylineProjectionWithOffsetResult.html">MR::PolylineProjectionWithOffsetResult&lt; V &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMR_1_1UniqueThreadSafeOwner.html">MR::UniqueThreadSafeOwner&lt; T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gad692565ba80610283f4322d081a95ef8"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__AABBTreeGroup.html#gad692565ba80610283f4322d081a95ef8">MR::FaceTreeTraits3</a> = <a class="el" href="structMR_1_1ABBTreeTraits.html">ABBTreeTraits</a>&lt; <a class="el" href="namespaceMR.html#a4234a65e90443b87f6412b4e681a38ac">FaceId</a>, <a class="el" href="namespaceMR.html#ada98ebf3fec74759dd46700389a3e556">Box3f</a> &gt;</td></tr>
<tr class="separator:gad692565ba80610283f4322d081a95ef8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga17af3e1b79216c9f09669326d43cf22d"><td class="memTemplParams" colspan="2">template&lt;typename V &gt; </td></tr>
<tr class="memitem:ga17af3e1b79216c9f09669326d43cf22d"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__AABBTreeGroup.html#ga17af3e1b79216c9f09669326d43cf22d">MR::LineTreeTraits</a> = <a class="el" href="structMR_1_1ABBTreeTraits.html">ABBTreeTraits</a>&lt; <a class="el" href="namespaceMR.html#a65798dca01178b50da3bbd7968fb360e">UndirectedEdgeId</a>, <a class="el" href="structMR_1_1Box.html">Box</a>&lt; V &gt; &gt;</td></tr>
<tr class="separator:ga17af3e1b79216c9f09669326d43cf22d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae0095cba19362d8f40a9beaedc20b142"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__AABBTreeGroup.html#gae0095cba19362d8f40a9beaedc20b142">MR::LineTreeTraits2</a> = <a class="el" href="group__AABBTreeGroup.html#ga17af3e1b79216c9f09669326d43cf22d">LineTreeTraits</a>&lt; <a class="el" href="namespaceMR.html#a61594f31bab4ef06a3f164c0199198e7">Vector2f</a> &gt;</td></tr>
<tr class="separator:gae0095cba19362d8f40a9beaedc20b142"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9e0548c1f8dc47ae420a227a56165c7c"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__AABBTreeGroup.html#ga9e0548c1f8dc47ae420a227a56165c7c">MR::LineTreeTraits3</a> = <a class="el" href="group__AABBTreeGroup.html#ga17af3e1b79216c9f09669326d43cf22d">LineTreeTraits</a>&lt; <a class="el" href="namespaceMR.html#a5f4a954ba7d1785cafcb2f7ffe7acf09">Vector3f</a> &gt;</td></tr>
<tr class="separator:ga9e0548c1f8dc47ae420a227a56165c7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga34a8bbcd6701c78c61502a42e3a1dca0"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga34a8bbcd6701c78c61502a42e3a1dca0"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__AABBTreeGroup.html#ga34a8bbcd6701c78c61502a42e3a1dca0">MR::AABBTreeNodeId</a> = typename <a class="el" href="structMR_1_1AABBTreeNode.html">AABBTreeNode</a>&lt; T &gt;::NodeId</td></tr>
<tr class="separator:ga34a8bbcd6701c78c61502a42e3a1dca0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0dc29c20db23419ffc06b5a3a0244204"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga0dc29c20db23419ffc06b5a3a0244204"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__AABBTreeGroup.html#ga0dc29c20db23419ffc06b5a3a0244204">MR::AABBTreeNodeVec</a> = <a class="el" href="classMR_1_1Vector.html">Vector</a>&lt; <a class="el" href="structMR_1_1AABBTreeNode.html">AABBTreeNode</a>&lt; T &gt;, <a class="el" href="group__AABBTreeGroup.html#ga34a8bbcd6701c78c61502a42e3a1dca0">AABBTreeNodeId</a>&lt; T &gt; &gt;</td></tr>
<tr class="separator:ga0dc29c20db23419ffc06b5a3a0244204"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa1341f2eec34b89f628200697d1c55a1"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__AABBTreeGroup.html#gaa1341f2eec34b89f628200697d1c55a1">MR::ConvertToIntVector</a> = std::function&lt; <a class="el" href="namespaceMR.html#af24b71b1cf7ac2e3a63c2d988fd599f0">Vector3i</a>(const <a class="el" href="namespaceMR.html#a5f4a954ba7d1785cafcb2f7ffe7acf09">Vector3f</a> &amp;)&gt;</td></tr>
<tr class="memdesc:gaa1341f2eec34b89f628200697d1c55a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">float-to-int coordinate converter  <br /></td></tr>
<tr class="separator:gaa1341f2eec34b89f628200697d1c55a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4835cdcf7f575fd6b4381c29fc920269"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__AABBTreeGroup.html#ga4835cdcf7f575fd6b4381c29fc920269">MR::ConvertToFloatVector</a> = std::function&lt; <a class="el" href="namespaceMR.html#a5f4a954ba7d1785cafcb2f7ffe7acf09">Vector3f</a>(const <a class="el" href="namespaceMR.html#af24b71b1cf7ac2e3a63c2d988fd599f0">Vector3i</a> &amp;)&gt;</td></tr>
<tr class="memdesc:ga4835cdcf7f575fd6b4381c29fc920269"><td class="mdescLeft">&#160;</td><td class="mdescRight">int-to-float coordinate converter  <br /></td></tr>
<tr class="separator:ga4835cdcf7f575fd6b4381c29fc920269"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga163d12cc5f6452ebe26a959afb1d5379"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__AABBTreeGroup.html#ga163d12cc5f6452ebe26a959afb1d5379">MR::TriangleCallback</a> = std::function&lt; <a class="el" href="group__AABBTreeGroup.html#ga3dd2fd9fcc06b6502d22a9ea3eb63e47">ProcessOneResult</a>(const <a class="el" href="namespaceMR.html#a5f4a954ba7d1785cafcb2f7ffe7acf09">Vector3f</a> &amp;p, <a class="el" href="namespaceMR.html#a4234a65e90443b87f6412b4e681a38ac">FaceId</a> f, const <a class="el" href="namespaceMR.html#a5f4a954ba7d1785cafcb2f7ffe7acf09">Vector3f</a> &amp;q, float distSq)&gt;</td></tr>
<tr class="separator:ga163d12cc5f6452ebe26a959afb1d5379"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5ab271790117f87421a1332a6c3e9d95"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__AABBTreeGroup.html#ga5ab271790117f87421a1332a6c3e9d95">MR::Line3fMesh</a> = <a class="el" href="structMR_1_1Line3Mesh.html">Line3Mesh</a>&lt; float &gt;</td></tr>
<tr class="separator:ga5ab271790117f87421a1332a6c3e9d95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaf317c41824870416408c08346c2171e"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__AABBTreeGroup.html#gaaf317c41824870416408c08346c2171e">MR::Line3dMesh</a> = <a class="el" href="structMR_1_1Line3Mesh.html">Line3Mesh</a>&lt; double &gt;</td></tr>
<tr class="separator:gaaf317c41824870416408c08346c2171e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab84b0b767274335b6f0f59bbb9537fe3"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__AABBTreeGroup.html#gab84b0b767274335b6f0f59bbb9537fe3">MR::MeshIntersectionCallback</a> = std::function&lt; bool(const <a class="el" href="structMR_1_1MeshIntersectionResult.html">MeshIntersectionResult</a> &amp;)&gt;</td></tr>
<tr class="separator:gab84b0b767274335b6f0f59bbb9537fe3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6567418169a65826fd82b440411a4fc4"><td class="memTemplParams" colspan="2">template&lt;typename V &gt; </td></tr>
<tr class="memitem:ga6567418169a65826fd82b440411a4fc4"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__AABBTreeGroup.html#ga6567418169a65826fd82b440411a4fc4">MR::FoundEdgeCallback</a> = std::function&lt; void(<a class="el" href="namespaceMR.html#a65798dca01178b50da3bbd7968fb360e">UndirectedEdgeId</a>, const V &amp;closestPt, float distSq)&gt;</td></tr>
<tr class="separator:ga6567418169a65826fd82b440411a4fc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4f844f73b163343e67f73579ee60eb3b"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__AABBTreeGroup.html#ga4f844f73b163343e67f73579ee60eb3b">MR::FoundEdgeCallback2</a> = <a class="el" href="group__AABBTreeGroup.html#ga6567418169a65826fd82b440411a4fc4">FoundEdgeCallback</a>&lt; <a class="el" href="namespaceMR.html#a61594f31bab4ef06a3f164c0199198e7">Vector2f</a> &gt;</td></tr>
<tr class="separator:ga4f844f73b163343e67f73579ee60eb3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf77c51a2927a660589bbe050fdbd6ac8"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__AABBTreeGroup.html#gaf77c51a2927a660589bbe050fdbd6ac8">MR::FoundEdgeCallback3</a> = <a class="el" href="group__AABBTreeGroup.html#ga6567418169a65826fd82b440411a4fc4">FoundEdgeCallback</a>&lt; <a class="el" href="namespaceMR.html#a5f4a954ba7d1785cafcb2f7ffe7acf09">Vector3f</a> &gt;</td></tr>
<tr class="separator:gaf77c51a2927a660589bbe050fdbd6ac8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga3dd2fd9fcc06b6502d22a9ea3eb63e47"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__AABBTreeGroup.html#ga3dd2fd9fcc06b6502d22a9ea3eb63e47">MR::ProcessOneResult</a> : bool { <a class="el" href="group__AABBTreeGroup.html#gga3dd2fd9fcc06b6502d22a9ea3eb63e47a38e59feb928e37292c8ee0a50f447612">MR::ProcessOneResult::StopProcessing</a> = false
, <a class="el" href="group__AABBTreeGroup.html#gga3dd2fd9fcc06b6502d22a9ea3eb63e47aab6bb60f51b25ae0f7ec450173e3348e">MR::ProcessOneResult::ContinueProcessing</a> = true
 }</td></tr>
<tr class="separator:ga3dd2fd9fcc06b6502d22a9ea3eb63e47"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga3c1bb6417aaa769fa4156f2edac91749"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__AABBTreeGroup.html#ga3c1bb6417aaa769fa4156f2edac91749">MR::getNumNodes</a> (int numLeaves)</td></tr>
<tr class="memdesc:ga3c1bb6417aaa769fa4156f2edac91749"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the number of nodes in the binary tree with given number of leaves  <br /></td></tr>
<tr class="separator:ga3c1bb6417aaa769fa4156f2edac91749"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga364302ddaf673e7f00c6745f4172d6c0"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga364302ddaf673e7f00c6745f4172d6c0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__AABBTreeGroup.html#ga0dc29c20db23419ffc06b5a3a0244204">AABBTreeNodeVec</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__AABBTreeGroup.html#ga364302ddaf673e7f00c6745f4172d6c0">MR::makeAABBTreeNodeVec</a> (<a class="el" href="classMR_1_1Buffer.html">Buffer</a>&lt; <a class="el" href="structMR_1_1BoxedLeaf.html">BoxedLeaf</a>&lt; T &gt; &gt; boxedLeaves)</td></tr>
<tr class="separator:ga364302ddaf673e7f00c6745f4172d6c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7fcb33a674ea8b57ac858e40d42e26e3"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga7fcb33a674ea8b57ac858e40d42e26e3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__AABBTreeGroup.html#ga7fcb33a674ea8b57ac858e40d42e26e3">MR::findMaxVectorDim</a> (int &amp;dimX, int &amp;dimY, int &amp;dimZ, const <a class="el" href="structMR_1_1Vector3.html">Vector3</a>&lt; T &gt; &amp;dir)</td></tr>
<tr class="memdesc:ga7fcb33a674ea8b57ac858e40d42e26e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">finds index of maximum axis and stores it into dimZ  <br /></td></tr>
<tr class="separator:ga7fcb33a674ea8b57ac858e40d42e26e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9984ed4cff38cd012243e835f02e0e92"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__AABBTreeGroup.html#ga9984ed4cff38cd012243e835f02e0e92">MR::IntersectionPrecomputes&lt; T &gt;::IntersectionPrecomputes</a> ()=default</td></tr>
<tr class="separator:ga9984ed4cff38cd012243e835f02e0e92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac2a5a2178c875139ca3e402c1a46324c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__AABBTreeGroup.html#gac2a5a2178c875139ca3e402c1a46324c">MR::IntersectionPrecomputes&lt; T &gt;::IntersectionPrecomputes</a> (const <a class="el" href="structMR_1_1Vector3.html">Vector3</a>&lt; T &gt; &amp;dir)</td></tr>
<tr class="separator:gac2a5a2178c875139ca3e402c1a46324c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga562052fddd56327be07ffe8c0cc7f7af"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga562052fddd56327be07ffe8c0cc7f7af"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__AABBTreeGroup.html#ga562052fddd56327be07ffe8c0cc7f7af">MR::findMaxVectorDim</a> (int &amp;dimX, int &amp;dimY, const <a class="el" href="structMR_1_1Vector2.html">Vector2</a>&lt; T &gt; &amp;dir)</td></tr>
<tr class="memdesc:ga562052fddd56327be07ffe8c0cc7f7af"><td class="mdescLeft">&#160;</td><td class="mdescRight">finds index of maximum axis and stores it into dimY  <br /></td></tr>
<tr class="separator:ga562052fddd56327be07ffe8c0cc7f7af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaeb209f0c917451a03debbf058fc39e6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> std::vector&lt; <a class="el" href="structMR_1_1FaceFace.html">FaceFace</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__AABBTreeGroup.html#gaaeb209f0c917451a03debbf058fc39e6">MR::findCollidingTriangles</a> (const <a class="el" href="structMR_1_1MeshPart.html">MeshPart</a> &amp;a, const <a class="el" href="structMR_1_1MeshPart.html">MeshPart</a> &amp;b, const <a class="el" href="namespaceMR.html#a9cf4b064aa13c5becce6312228c3c03b">AffineXf3f</a> *rigidB2A=nullptr, bool firstIntersectionOnly=false)</td></tr>
<tr class="memdesc:gaaeb209f0c917451a03debbf058fc39e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">finds all pairs of colliding triangles from two meshes or two mesh regions  <br /></td></tr>
<tr class="separator:gaaeb209f0c917451a03debbf058fc39e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga47e983a2ba53dbe6d49313488f3cae23"><td class="memItemLeft" align="right" valign="top"><a class="el" href="MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> std::pair&lt; <a class="el" href="namespaceMR.html#a0e5b61f8edf7a896c3f2f4a6eeb4691d">FaceBitSet</a>, <a class="el" href="namespaceMR.html#a0e5b61f8edf7a896c3f2f4a6eeb4691d">FaceBitSet</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__AABBTreeGroup.html#ga47e983a2ba53dbe6d49313488f3cae23">MR::findCollidingTriangleBitsets</a> (const <a class="el" href="structMR_1_1MeshPart.html">MeshPart</a> &amp;a, const <a class="el" href="structMR_1_1MeshPart.html">MeshPart</a> &amp;b, const <a class="el" href="namespaceMR.html#a9cf4b064aa13c5becce6312228c3c03b">AffineXf3f</a> *rigidB2A=nullptr)</td></tr>
<tr class="memdesc:ga47e983a2ba53dbe6d49313488f3cae23"><td class="mdescLeft">&#160;</td><td class="mdescRight">the same as <a class="el" href="group__AABBTreeGroup.html#gaaeb209f0c917451a03debbf058fc39e6">findCollidingTriangles</a>, but returns one bite set per mesh with colliding triangles  <br /></td></tr>
<tr class="separator:ga47e983a2ba53dbe6d49313488f3cae23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6d98c0d3c3c6ee98a1cea7662a3f704f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> <a class="el" href="namespaceMR.html#a9e4cb12e0805ba24e046ac622cdc33bb">Expected</a>&lt; std::vector&lt; <a class="el" href="structMR_1_1FaceFace.html">FaceFace</a> &gt;, std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__AABBTreeGroup.html#ga6d98c0d3c3c6ee98a1cea7662a3f704f">MR::findSelfCollidingTriangles</a> (const <a class="el" href="structMR_1_1MeshPart.html">MeshPart</a> &amp;mp, <a class="el" href="group__BasicStructuresGroup.html#ga51ff94746a41880cd06d3272b5bcf710">ProgressCallback</a> cb={})</td></tr>
<tr class="memdesc:ga6d98c0d3c3c6ee98a1cea7662a3f704f"><td class="mdescLeft">&#160;</td><td class="mdescRight">finds all pairs of colliding triangles from one mesh or a region  <br /></td></tr>
<tr class="separator:ga6d98c0d3c3c6ee98a1cea7662a3f704f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0268cc5d3075529584b5c17df4c22243"><td class="memItemLeft" align="right" valign="top"><a class="el" href="MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> <a class="el" href="namespaceMR.html#a9e4cb12e0805ba24e046ac622cdc33bb">Expected</a>&lt; <a class="el" href="namespaceMR.html#a0e5b61f8edf7a896c3f2f4a6eeb4691d">FaceBitSet</a>, std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__AABBTreeGroup.html#ga0268cc5d3075529584b5c17df4c22243">MR::findSelfCollidingTrianglesBS</a> (const <a class="el" href="structMR_1_1MeshPart.html">MeshPart</a> &amp;mp, <a class="el" href="group__BasicStructuresGroup.html#ga51ff94746a41880cd06d3272b5bcf710">ProgressCallback</a> cb={})</td></tr>
<tr class="memdesc:ga0268cc5d3075529584b5c17df4c22243"><td class="mdescLeft">&#160;</td><td class="mdescRight">the same <a class="el" href="group__AABBTreeGroup.html#ga6d98c0d3c3c6ee98a1cea7662a3f704f">findSelfCollidingTriangles</a> but returns the union of all self-intersecting faces  <br /></td></tr>
<tr class="separator:ga0268cc5d3075529584b5c17df4c22243"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3c4d304b28fd4695d20dc454318f5660"><td class="memItemLeft" align="right" valign="top"><a class="el" href="MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__AABBTreeGroup.html#ga3c4d304b28fd4695d20dc454318f5660">MR::isInside</a> (const <a class="el" href="structMR_1_1MeshPart.html">MeshPart</a> &amp;a, const <a class="el" href="structMR_1_1MeshPart.html">MeshPart</a> &amp;b, const <a class="el" href="namespaceMR.html#a9cf4b064aa13c5becce6312228c3c03b">AffineXf3f</a> *rigidB2A=nullptr)</td></tr>
<tr class="memdesc:ga3c4d304b28fd4695d20dc454318f5660"><td class="mdescLeft">&#160;</td><td class="mdescRight">checks that arbitrary mesh part A is inside of closed mesh part B  <br /></td></tr>
<tr class="separator:ga3c4d304b28fd4695d20dc454318f5660"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga30d53ebf69ce150861f17e4695543778"><td class="memItemLeft" align="right" valign="top"><a class="el" href="MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__AABBTreeGroup.html#ga30d53ebf69ce150861f17e4695543778">MR::isNonIntersectingInside</a> (const <a class="el" href="structMR_1_1MeshPart.html">MeshPart</a> &amp;a, const <a class="el" href="structMR_1_1MeshPart.html">MeshPart</a> &amp;b, const <a class="el" href="namespaceMR.html#a9cf4b064aa13c5becce6312228c3c03b">AffineXf3f</a> *rigidB2A=nullptr)</td></tr>
<tr class="memdesc:ga30d53ebf69ce150861f17e4695543778"><td class="mdescLeft">&#160;</td><td class="mdescRight">checks that arbitrary mesh part A is inside of closed mesh part B The version of <code>isInside</code> without collision check; it is user's responsibility to guarantee that the meshes don't collide  <br /></td></tr>
<tr class="separator:ga30d53ebf69ce150861f17e4695543778"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8f7cfd40975f9648e9785f72d75ff92d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__AABBTreeGroup.html#ga8f7cfd40975f9648e9785f72d75ff92d">MR::operator==</a> (const <a class="el" href="structMR_1_1EdgeTri.html">EdgeTri</a> &amp;a, const <a class="el" href="structMR_1_1EdgeTri.html">EdgeTri</a> &amp;b)</td></tr>
<tr class="separator:ga8f7cfd40975f9648e9785f72d75ff92d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga11d4ca955f1a62e15ebea578ffa83454"><td class="memItemLeft" align="right" valign="top"><a class="el" href="MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> <a class="el" href="structMR_1_1PreciseCollisionResult.html">PreciseCollisionResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__AABBTreeGroup.html#ga11d4ca955f1a62e15ebea578ffa83454">MR::findCollidingEdgeTrisPrecise</a> (const <a class="el" href="structMR_1_1MeshPart.html">MeshPart</a> &amp;a, const <a class="el" href="structMR_1_1MeshPart.html">MeshPart</a> &amp;b, <a class="el" href="group__AABBTreeGroup.html#gaa1341f2eec34b89f628200697d1c55a1">ConvertToIntVector</a> conv, const <a class="el" href="namespaceMR.html#a9cf4b064aa13c5becce6312228c3c03b">AffineXf3f</a> *rigidB2A=nullptr, bool anyIntersection=false)</td></tr>
<tr class="memdesc:ga11d4ca955f1a62e15ebea578ffa83454"><td class="mdescLeft">&#160;</td><td class="mdescRight">finds all pairs of colliding edges from one mesh and triangle from another mesh  <br /></td></tr>
<tr class="separator:ga11d4ca955f1a62e15ebea578ffa83454"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8c7d357b072699f62023d97ea1c81f45"><td class="memItemLeft" align="right" valign="top"><a class="el" href="MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> std::vector&lt; <a class="el" href="structMR_1_1EdgeTri.html">EdgeTri</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__AABBTreeGroup.html#ga8c7d357b072699f62023d97ea1c81f45">MR::findCollidingEdgeTrisPrecise</a> (const <a class="el" href="structMR_1_1Mesh.html">Mesh</a> &amp;a, const std::vector&lt; <a class="el" href="namespaceMR.html#a82c7618d8fb2b9dd9a8c5ea89be1b0f1">EdgeId</a> &gt; &amp;edgesA, const <a class="el" href="structMR_1_1Mesh.html">Mesh</a> &amp;b, const std::vector&lt; <a class="el" href="namespaceMR.html#a4234a65e90443b87f6412b4e681a38ac">FaceId</a> &gt; &amp;facesB, <a class="el" href="group__AABBTreeGroup.html#gaa1341f2eec34b89f628200697d1c55a1">ConvertToIntVector</a> conv, const <a class="el" href="namespaceMR.html#a9cf4b064aa13c5becce6312228c3c03b">AffineXf3f</a> *rigidB2A=nullptr)</td></tr>
<tr class="memdesc:ga8c7d357b072699f62023d97ea1c81f45"><td class="mdescLeft">&#160;</td><td class="mdescRight">finds all intersections between every given edge from A and given triangles from B  <br /></td></tr>
<tr class="separator:ga8c7d357b072699f62023d97ea1c81f45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga939afe34134c1d66c9ca5f19e33dc323"><td class="memItemLeft" align="right" valign="top"><a class="el" href="MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> std::vector&lt; <a class="el" href="structMR_1_1EdgeTri.html">EdgeTri</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__AABBTreeGroup.html#ga939afe34134c1d66c9ca5f19e33dc323">MR::findCollidingEdgeTrisPrecise</a> (const <a class="el" href="structMR_1_1Mesh.html">Mesh</a> &amp;a, const std::vector&lt; <a class="el" href="namespaceMR.html#a4234a65e90443b87f6412b4e681a38ac">FaceId</a> &gt; &amp;facesA, const <a class="el" href="structMR_1_1Mesh.html">Mesh</a> &amp;b, const std::vector&lt; <a class="el" href="namespaceMR.html#a82c7618d8fb2b9dd9a8c5ea89be1b0f1">EdgeId</a> &gt; &amp;edgesB, <a class="el" href="group__AABBTreeGroup.html#gaa1341f2eec34b89f628200697d1c55a1">ConvertToIntVector</a> conv, const <a class="el" href="namespaceMR.html#a9cf4b064aa13c5becce6312228c3c03b">AffineXf3f</a> *rigidB2A=nullptr)</td></tr>
<tr class="memdesc:ga939afe34134c1d66c9ca5f19e33dc323"><td class="mdescLeft">&#160;</td><td class="mdescRight">finds all intersections between every given triangle from A and given edge from B  <br /></td></tr>
<tr class="separator:ga939afe34134c1d66c9ca5f19e33dc323"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9736a434a7f001c05b9a7d23675ca257"><td class="memItemLeft" align="right" valign="top"><a class="el" href="MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> <a class="el" href="group__AABBTreeGroup.html#gaa1341f2eec34b89f628200697d1c55a1">ConvertToIntVector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__AABBTreeGroup.html#ga9736a434a7f001c05b9a7d23675ca257">MR::getToIntConverter</a> (const <a class="el" href="namespaceMR.html#a438e80434fdd3ef1a3d09e32a3d593d5">Box3d</a> &amp;box)</td></tr>
<tr class="memdesc:ga9736a434a7f001c05b9a7d23675ca257"><td class="mdescLeft">&#160;</td><td class="mdescRight">creates converter from Vector3f to Vector3i in <a class="el" href="structMR_1_1Box.html" title="Box given by its min- and max- corners.">Box</a> range (int diapason is mapped to box range)  <br /></td></tr>
<tr class="separator:ga9736a434a7f001c05b9a7d23675ca257"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2096ace9292b40c55421517434fd8bd8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> <a class="el" href="group__AABBTreeGroup.html#ga4835cdcf7f575fd6b4381c29fc920269">ConvertToFloatVector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__AABBTreeGroup.html#ga2096ace9292b40c55421517434fd8bd8">MR::getToFloatConverter</a> (const <a class="el" href="namespaceMR.html#a438e80434fdd3ef1a3d09e32a3d593d5">Box3d</a> &amp;box)</td></tr>
<tr class="memdesc:ga2096ace9292b40c55421517434fd8bd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">creates converter from Vector3i to Vector3f in <a class="el" href="structMR_1_1Box.html" title="Box given by its min- and max- corners.">Box</a> range (int diapason is mapped to box range)  <br /></td></tr>
<tr class="separator:ga2096ace9292b40c55421517434fd8bd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga125d7b99c7b4840e87a3470ef0c64b17"><td class="memItemLeft" align="right" valign="top"><a class="el" href="MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> <a class="el" href="structMR_1_1CoordinateConverters.html">CoordinateConverters</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__AABBTreeGroup.html#ga125d7b99c7b4840e87a3470ef0c64b17">MR::getVectorConverters</a> (const <a class="el" href="structMR_1_1MeshPart.html">MeshPart</a> &amp;a, const <a class="el" href="structMR_1_1MeshPart.html">MeshPart</a> &amp;b, const <a class="el" href="namespaceMR.html#a9cf4b064aa13c5becce6312228c3c03b">AffineXf3f</a> *rigidB2A=nullptr)</td></tr>
<tr class="memdesc:ga125d7b99c7b4840e87a3470ef0c64b17"><td class="mdescLeft">&#160;</td><td class="mdescRight">creates simple converters from Vector3f to Vector3i and back in mesh parts area range  <br /></td></tr>
<tr class="separator:ga125d7b99c7b4840e87a3470ef0c64b17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf49d29fe114a45e7ba44769ed23e07a7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> <a class="el" href="namespaceMR.html#a2f4408b5ff9250509a9d18a04d6f1fb5">VertId</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__AABBTreeGroup.html#gaf49d29fe114a45e7ba44769ed23e07a7">MR::findDirMax</a> (const <a class="el" href="namespaceMR.html#a5f4a954ba7d1785cafcb2f7ffe7acf09">Vector3f</a> &amp;dir, const <a class="el" href="structMR_1_1MeshPart.html">MeshPart</a> &amp;mp, <a class="el" href="namespaceMR.html#afb67fe49bcb6006882e7b08e51b2eeff">UseAABBTree</a> u=<a class="el" href="namespaceMR.html#afb67fe49bcb6006882e7b08e51b2eeffa93cba07454f06a4a960172bbd6e2a435">UseAABBTree::Yes</a>)</td></tr>
<tr class="separator:gaf49d29fe114a45e7ba44769ed23e07a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae8acc67c54f5f060c954bb3528a0c581"><td class="memItemLeft" align="right" valign="top"><a class="el" href="MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> <a class="el" href="structMR_1_1MeshDistanceResult.html">MeshDistanceResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__AABBTreeGroup.html#gae8acc67c54f5f060c954bb3528a0c581">MR::findDistance</a> (const <a class="el" href="structMR_1_1MeshPart.html">MeshPart</a> &amp;a, const <a class="el" href="structMR_1_1MeshPart.html">MeshPart</a> &amp;b, const <a class="el" href="namespaceMR.html#a9cf4b064aa13c5becce6312228c3c03b">AffineXf3f</a> *rigidB2A=nullptr, float upDistLimitSq=FLT_MAX)</td></tr>
<tr class="memdesc:gae8acc67c54f5f060c954bb3528a0c581"><td class="mdescLeft">&#160;</td><td class="mdescRight">computes minimal distance between two meshes or two mesh regions  <br /></td></tr>
<tr class="separator:gae8acc67c54f5f060c954bb3528a0c581"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga66ee7b0ec534fcfe70ef96f8f3d3b545"><td class="memItemLeft" align="right" valign="top"><a class="el" href="MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> <a class="el" href="structMR_1_1MeshSignedDistanceResult.html">MeshSignedDistanceResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__AABBTreeGroup.html#ga66ee7b0ec534fcfe70ef96f8f3d3b545">MR::findSignedDistance</a> (const <a class="el" href="structMR_1_1MeshPart.html">MeshPart</a> &amp;a, const <a class="el" href="structMR_1_1MeshPart.html">MeshPart</a> &amp;b, const <a class="el" href="namespaceMR.html#a9cf4b064aa13c5becce6312228c3c03b">AffineXf3f</a> *rigidB2A=nullptr, float upDistLimitSq=FLT_MAX)</td></tr>
<tr class="memdesc:ga66ee7b0ec534fcfe70ef96f8f3d3b545"><td class="mdescLeft">&#160;</td><td class="mdescRight">computes minimal distance between two meshes  <br /></td></tr>
<tr class="separator:ga66ee7b0ec534fcfe70ef96f8f3d3b545"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga375d9c9dcfb1fd7d9a254a73370d71ba"><td class="memItemLeft" align="right" valign="top"><a class="el" href="MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__AABBTreeGroup.html#ga375d9c9dcfb1fd7d9a254a73370d71ba">MR::findMaxDistanceSqOneWay</a> (const <a class="el" href="structMR_1_1MeshPart.html">MeshPart</a> &amp;a, const <a class="el" href="structMR_1_1MeshPart.html">MeshPart</a> &amp;b, const <a class="el" href="namespaceMR.html#a9cf4b064aa13c5becce6312228c3c03b">AffineXf3f</a> *rigidB2A=nullptr, float maxDistanceSq=FLT_MAX)</td></tr>
<tr class="memdesc:ga375d9c9dcfb1fd7d9a254a73370d71ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the maximum of the squared distances from each B-mesh vertex to A-mesh  <br /></td></tr>
<tr class="separator:ga375d9c9dcfb1fd7d9a254a73370d71ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3672072155e3f272d13a40ccd4645d02"><td class="memItemLeft" align="right" valign="top"><a class="el" href="MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__AABBTreeGroup.html#ga3672072155e3f272d13a40ccd4645d02">MR::findMaxDistanceSq</a> (const <a class="el" href="structMR_1_1MeshPart.html">MeshPart</a> &amp;a, const <a class="el" href="structMR_1_1MeshPart.html">MeshPart</a> &amp;b, const <a class="el" href="namespaceMR.html#a9cf4b064aa13c5becce6312228c3c03b">AffineXf3f</a> *rigidB2A=nullptr, float maxDistanceSq=FLT_MAX)</td></tr>
<tr class="memdesc:ga3672072155e3f272d13a40ccd4645d02"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the squared Hausdorff distance between two meshes, that is the maximum of squared distances from each mesh vertex to the other mesh (in both directions)  <br /></td></tr>
<tr class="separator:ga3672072155e3f272d13a40ccd4645d02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadb20234daa82631954c44c1676424e5f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__AABBTreeGroup.html#gadb20234daa82631954c44c1676424e5f">MR::processCloseTriangles</a> (const <a class="el" href="structMR_1_1MeshPart.html">MeshPart</a> &amp;mp, const <a class="el" href="namespaceMR.html#a34931e18c46a0007ca98d04847051247">Triangle3f</a> &amp;t, float rangeSq, const <a class="el" href="group__AABBTreeGroup.html#ga163d12cc5f6452ebe26a959afb1d5379">TriangleCallback</a> &amp;call)</td></tr>
<tr class="separator:gadb20234daa82631954c44c1676424e5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabc0eec956303a3e852dd8f7e07f55d12"><td class="memItemLeft" align="right" valign="top"><a class="el" href="MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> std::optional&lt; <a class="el" href="structMR_1_1MeshIntersectionResult.html">MeshIntersectionResult</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__AABBTreeGroup.html#gabc0eec956303a3e852dd8f7e07f55d12">MR::rayMeshIntersect</a> (const <a class="el" href="structMR_1_1MeshPart.html">MeshPart</a> &amp;meshPart, const <a class="el" href="namespaceMR.html#acfd96aa6798933e1a002144fb0dc22af">Line3f</a> &amp;line, float rayStart=0.0f, float rayEnd=FLT_MAX, const <a class="el" href="structMR_1_1IntersectionPrecomputes.html">IntersectionPrecomputes</a>&lt; float &gt; *prec=nullptr, bool closestIntersect=true)</td></tr>
<tr class="separator:gabc0eec956303a3e852dd8f7e07f55d12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga046de9351673df9583898d31c01e297c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> std::optional&lt; <a class="el" href="structMR_1_1MeshIntersectionResult.html">MeshIntersectionResult</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__AABBTreeGroup.html#ga046de9351673df9583898d31c01e297c">MR::rayMeshIntersect</a> (const <a class="el" href="structMR_1_1MeshPart.html">MeshPart</a> &amp;meshPart, const <a class="el" href="namespaceMR.html#ad78dde2996d3a2b85bb7fd22db18efb6">Line3d</a> &amp;line, double rayStart=0.0, double rayEnd=DBL_MAX, const <a class="el" href="structMR_1_1IntersectionPrecomputes.html">IntersectionPrecomputes</a>&lt; double &gt; *prec=nullptr, bool closestIntersect=true)</td></tr>
<tr class="separator:ga046de9351673df9583898d31c01e297c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga541656ec925c37fde32a91a25444e35f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> std::optional&lt; <a class="el" href="structMR_1_1MultiMeshIntersectionResult.html">MultiMeshIntersectionResult</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__AABBTreeGroup.html#ga541656ec925c37fde32a91a25444e35f">MR::rayMultiMeshAnyIntersect</a> (const std::vector&lt; <a class="el" href="group__AABBTreeGroup.html#ga5ab271790117f87421a1332a6c3e9d95">Line3fMesh</a> &gt; &amp;lineMeshes, float rayStart=0.0f, float rayEnd=FLT_MAX)</td></tr>
<tr class="separator:ga541656ec925c37fde32a91a25444e35f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga240b42f542774e3965806c916ba298ba"><td class="memItemLeft" align="right" valign="top"><a class="el" href="MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> std::optional&lt; <a class="el" href="structMR_1_1MultiMeshIntersectionResult.html">MultiMeshIntersectionResult</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__AABBTreeGroup.html#ga240b42f542774e3965806c916ba298ba">MR::rayMultiMeshAnyIntersect</a> (const std::vector&lt; <a class="el" href="group__AABBTreeGroup.html#gaaf317c41824870416408c08346c2171e">Line3dMesh</a> &gt; &amp;lineMeshes, double rayStart=0.0, double rayEnd=DBL_MAX)</td></tr>
<tr class="memdesc:ga240b42f542774e3965806c916ba298ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <a class="el" href="group__AABBTreeGroup.html#rayMultiMeshAnyIntersectF">rayMultiMeshAnyIntersectF</a>, but use double precision.  <br /></td></tr>
<tr class="separator:ga240b42f542774e3965806c916ba298ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac978c520f500c1e3dad2ddaff7a333f0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__AABBTreeGroup.html#gac978c520f500c1e3dad2ddaff7a333f0">MR::rayMeshIntersectAll</a> (const <a class="el" href="structMR_1_1MeshPart.html">MeshPart</a> &amp;meshPart, const <a class="el" href="namespaceMR.html#acfd96aa6798933e1a002144fb0dc22af">Line3f</a> &amp;line, <a class="el" href="group__AABBTreeGroup.html#gab84b0b767274335b6f0f59bbb9537fe3">MeshIntersectionCallback</a> callback, float rayStart=0.0f, float rayEnd=FLT_MAX, const <a class="el" href="structMR_1_1IntersectionPrecomputes.html">IntersectionPrecomputes</a>&lt; float &gt; *prec=nullptr)</td></tr>
<tr class="separator:gac978c520f500c1e3dad2ddaff7a333f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4f7fec7775a22ca743ad08d9b8ae3056"><td class="memItemLeft" align="right" valign="top"><a class="el" href="MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__AABBTreeGroup.html#ga4f7fec7775a22ca743ad08d9b8ae3056">MR::rayMeshIntersectAll</a> (const <a class="el" href="structMR_1_1MeshPart.html">MeshPart</a> &amp;meshPart, const <a class="el" href="namespaceMR.html#ad78dde2996d3a2b85bb7fd22db18efb6">Line3d</a> &amp;line, <a class="el" href="group__AABBTreeGroup.html#gab84b0b767274335b6f0f59bbb9537fe3">MeshIntersectionCallback</a> callback, double rayStart=0.0, double rayEnd=DBL_MAX, const <a class="el" href="structMR_1_1IntersectionPrecomputes.html">IntersectionPrecomputes</a>&lt; double &gt; *prec=nullptr)</td></tr>
<tr class="memdesc:ga4f7fec7775a22ca743ad08d9b8ae3056"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <a class="el" href="group__AABBTreeGroup.html#rayMeshIntersectAllF">rayMeshIntersectAllF</a>, but use double precision.  <br /></td></tr>
<tr class="separator:ga4f7fec7775a22ca743ad08d9b8ae3056"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga881bc4cb6ab7f415bf85d9235e2ca740"><td class="memItemLeft" align="right" valign="top"><a class="el" href="MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__AABBTreeGroup.html#ga881bc4cb6ab7f415bf85d9235e2ca740">MR::xyPlaneMeshIntersect</a> (const <a class="el" href="structMR_1_1MeshPart.html">MeshPart</a> &amp;meshPart, float zLevel, <a class="el" href="namespaceMR.html#a0e5b61f8edf7a896c3f2f4a6eeb4691d">FaceBitSet</a> *fs, <a class="el" href="namespaceMR.html#ae5a4467feb7b60cd337643529597aaaa">UndirectedEdgeBitSet</a> *ues, <a class="el" href="namespaceMR.html#ab615a9e54d407017abd63d056ce4be66">VertBitSet</a> *vs)</td></tr>
<tr class="separator:ga881bc4cb6ab7f415bf85d9235e2ca740"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaca9ee6c07f32374a18e511487904370b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> <a class="el" href="structMR_1_1MeshProjectionResult.html">MeshProjectionResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__AABBTreeGroup.html#gaca9ee6c07f32374a18e511487904370b">MR::findProjection</a> (const <a class="el" href="namespaceMR.html#a5f4a954ba7d1785cafcb2f7ffe7acf09">Vector3f</a> &amp;pt, const <a class="el" href="structMR_1_1MeshPart.html">MeshPart</a> &amp;mp, float upDistLimitSq=FLT_MAX, const <a class="el" href="namespaceMR.html#a9cf4b064aa13c5becce6312228c3c03b">AffineXf3f</a> *xf=nullptr, float loDistLimitSq=0, <a class="el" href="namespaceMR.html#a4234a65e90443b87f6412b4e681a38ac">FaceId</a> skipFace={})</td></tr>
<tr class="memdesc:gaca9ee6c07f32374a18e511487904370b"><td class="mdescLeft">&#160;</td><td class="mdescRight">computes the closest point on mesh (or its region) to given point  <br /></td></tr>
<tr class="separator:gaca9ee6c07f32374a18e511487904370b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga44d0cb5151cae38d27130277c50301bc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> std::optional&lt; <a class="el" href="structMR_1_1SignedDistanceToMeshResult.html">SignedDistanceToMeshResult</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__AABBTreeGroup.html#ga44d0cb5151cae38d27130277c50301bc">MR::findSignedDistance</a> (const <a class="el" href="namespaceMR.html#a5f4a954ba7d1785cafcb2f7ffe7acf09">Vector3f</a> &amp;pt, const <a class="el" href="structMR_1_1MeshPart.html">MeshPart</a> &amp;mp, float upDistLimitSq=FLT_MAX, float loDistLimitSq=0)</td></tr>
<tr class="memdesc:ga44d0cb5151cae38d27130277c50301bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">computes the closest point on mesh (or its region) to given point, and finds the distance with sign to it (positive - outside, negative - inside the mesh)  <br /></td></tr>
<tr class="separator:ga44d0cb5151cae38d27130277c50301bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5c540a8264b2d4cd39a35ce8600e873e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__AABBTreeGroup.html#ga5c540a8264b2d4cd39a35ce8600e873e">MR::findPointsInBall</a> (const <a class="el" href="structMR_1_1PointCloud.html">PointCloud</a> &amp;pointCloud, const <a class="el" href="namespaceMR.html#a5f4a954ba7d1785cafcb2f7ffe7acf09">Vector3f</a> &amp;center, float radius, const <a class="el" href="namespaceMR.html#ac4f1361c3362959c175d914a777b236d">FoundPointCallback</a> &amp;foundCallback, const <a class="el" href="namespaceMR.html#a9cf4b064aa13c5becce6312228c3c03b">AffineXf3f</a> *xf=nullptr)</td></tr>
<tr class="separator:ga5c540a8264b2d4cd39a35ce8600e873e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga47bd19da135ff2a820eebd760da392a3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__AABBTreeGroup.html#ga47bd19da135ff2a820eebd760da392a3">MR::findPointsInBall</a> (const <a class="el" href="structMR_1_1Mesh.html">Mesh</a> &amp;mesh, const <a class="el" href="namespaceMR.html#a5f4a954ba7d1785cafcb2f7ffe7acf09">Vector3f</a> &amp;center, float radius, const <a class="el" href="namespaceMR.html#ac4f1361c3362959c175d914a777b236d">FoundPointCallback</a> &amp;foundCallback, const <a class="el" href="namespaceMR.html#a9cf4b064aa13c5becce6312228c3c03b">AffineXf3f</a> *xf=nullptr)</td></tr>
<tr class="separator:ga47bd19da135ff2a820eebd760da392a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga80e8bb354705c40373b5a8a3d1a3376c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__AABBTreeGroup.html#ga80e8bb354705c40373b5a8a3d1a3376c">MR::findPointsInBall</a> (const <a class="el" href="classMR_1_1AABBTreePoints.html">AABBTreePoints</a> &amp;tree, const <a class="el" href="namespaceMR.html#a5f4a954ba7d1785cafcb2f7ffe7acf09">Vector3f</a> &amp;center, float radius, const <a class="el" href="namespaceMR.html#ac4f1361c3362959c175d914a777b236d">FoundPointCallback</a> &amp;foundCallback, const <a class="el" href="namespaceMR.html#a9cf4b064aa13c5becce6312228c3c03b">AffineXf3f</a> *xf=nullptr)</td></tr>
<tr class="separator:ga80e8bb354705c40373b5a8a3d1a3376c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga91f4a4e75eedf94f3028f574f0028dfb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> <a class="el" href="structMR_1_1PointsProjectionResult.html">PointsProjectionResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__AABBTreeGroup.html#ga91f4a4e75eedf94f3028f574f0028dfb">MR::findProjectionOnPoints</a> (const <a class="el" href="namespaceMR.html#a5f4a954ba7d1785cafcb2f7ffe7acf09">Vector3f</a> &amp;pt, const <a class="el" href="structMR_1_1PointCloud.html">PointCloud</a> &amp;pc, float upDistLimitSq=FLT_MAX, const <a class="el" href="namespaceMR.html#a9cf4b064aa13c5becce6312228c3c03b">AffineXf3f</a> *xf=nullptr, float loDistLimitSq=0)</td></tr>
<tr class="memdesc:ga91f4a4e75eedf94f3028f574f0028dfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">computes the closest point on point cloud to given point  <br /></td></tr>
<tr class="separator:ga91f4a4e75eedf94f3028f574f0028dfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga15a3e18d2098f8ff33e67776a221e6fb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> std::vector&lt; <a class="el" href="structMR_1_1EdgePointPair.html">EdgePointPair</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__AABBTreeGroup.html#ga15a3e18d2098f8ff33e67776a221e6fb">MR::findCollidingEdgePairs</a> (const <a class="el" href="namespaceMR.html#ab1ca9892644603a8b29005353e5ada79">Polyline2</a> &amp;a, const <a class="el" href="namespaceMR.html#ab1ca9892644603a8b29005353e5ada79">Polyline2</a> &amp;b, const <a class="el" href="namespaceMR.html#aaf5a1eb99830c5d7196aa5bf3a05f70e">AffineXf2f</a> *rigidB2A=nullptr, bool firstIntersectionOnly=false)</td></tr>
<tr class="memdesc:ga15a3e18d2098f8ff33e67776a221e6fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">finds all pairs of colliding edges from two 2d polylines  <br /></td></tr>
<tr class="separator:ga15a3e18d2098f8ff33e67776a221e6fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga44c8af10ceaf3059a77647d7b6f2ca8b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> std::vector&lt; <a class="el" href="structMR_1_1UndirectedEdgeUndirectedEdge.html">UndirectedEdgeUndirectedEdge</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__AABBTreeGroup.html#ga44c8af10ceaf3059a77647d7b6f2ca8b">MR::findCollidingEdges</a> (const <a class="el" href="namespaceMR.html#ab1ca9892644603a8b29005353e5ada79">Polyline2</a> &amp;a, const <a class="el" href="namespaceMR.html#ab1ca9892644603a8b29005353e5ada79">Polyline2</a> &amp;b, const <a class="el" href="namespaceMR.html#aaf5a1eb99830c5d7196aa5bf3a05f70e">AffineXf2f</a> *rigidB2A=nullptr, bool firstIntersectionOnly=false)</td></tr>
<tr class="memdesc:ga44c8af10ceaf3059a77647d7b6f2ca8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">finds all pairs of colliding edges from two 2d polylines  <br /></td></tr>
<tr class="separator:ga44c8af10ceaf3059a77647d7b6f2ca8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0f3404724c88f935957c8c3c8962ea3a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> std::pair&lt; <a class="el" href="namespaceMR.html#ae5a4467feb7b60cd337643529597aaaa">UndirectedEdgeBitSet</a>, <a class="el" href="namespaceMR.html#ae5a4467feb7b60cd337643529597aaaa">UndirectedEdgeBitSet</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__AABBTreeGroup.html#ga0f3404724c88f935957c8c3c8962ea3a">MR::findCollidingEdgesBitsets</a> (const <a class="el" href="namespaceMR.html#ab1ca9892644603a8b29005353e5ada79">Polyline2</a> &amp;a, const <a class="el" href="namespaceMR.html#ab1ca9892644603a8b29005353e5ada79">Polyline2</a> &amp;b, const <a class="el" href="namespaceMR.html#aaf5a1eb99830c5d7196aa5bf3a05f70e">AffineXf2f</a> *rigidB2A=nullptr)</td></tr>
<tr class="memdesc:ga0f3404724c88f935957c8c3c8962ea3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">finds bitset per polyline with colliding edges  <br /></td></tr>
<tr class="separator:ga0f3404724c88f935957c8c3c8962ea3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4fca223a68dac564f66af0224c0ec3ec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> std::vector&lt; <a class="el" href="structMR_1_1EdgePointPair.html">EdgePointPair</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__AABBTreeGroup.html#ga4fca223a68dac564f66af0224c0ec3ec">MR::findSelfCollidingEdgePairs</a> (const <a class="el" href="namespaceMR.html#ab1ca9892644603a8b29005353e5ada79">Polyline2</a> &amp;polyline)</td></tr>
<tr class="memdesc:ga4fca223a68dac564f66af0224c0ec3ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">finds all pairs of colliding edges from 2d polyline  <br /></td></tr>
<tr class="separator:ga4fca223a68dac564f66af0224c0ec3ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad89aed99c2cba4cd08e06d896b839841"><td class="memItemLeft" align="right" valign="top"><a class="el" href="MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> std::vector&lt; <a class="el" href="structMR_1_1UndirectedEdgeUndirectedEdge.html">UndirectedEdgeUndirectedEdge</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__AABBTreeGroup.html#gad89aed99c2cba4cd08e06d896b839841">MR::findSelfCollidingEdges</a> (const <a class="el" href="namespaceMR.html#ab1ca9892644603a8b29005353e5ada79">Polyline2</a> &amp;polyline)</td></tr>
<tr class="memdesc:gad89aed99c2cba4cd08e06d896b839841"><td class="mdescLeft">&#160;</td><td class="mdescRight">finds all pairs of colliding edges from 2d polyline  <br /></td></tr>
<tr class="separator:gad89aed99c2cba4cd08e06d896b839841"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8658f18b6b0489c1dafa4903c64c0165"><td class="memItemLeft" align="right" valign="top"><a class="el" href="MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> <a class="el" href="namespaceMR.html#ae5a4467feb7b60cd337643529597aaaa">UndirectedEdgeBitSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__AABBTreeGroup.html#ga8658f18b6b0489c1dafa4903c64c0165">MR::findSelfCollidingEdgesBS</a> (const <a class="el" href="namespaceMR.html#ab1ca9892644603a8b29005353e5ada79">Polyline2</a> &amp;polyline)</td></tr>
<tr class="memdesc:ga8658f18b6b0489c1dafa4903c64c0165"><td class="mdescLeft">&#160;</td><td class="mdescRight">finds the union of all self-intersecting edges  <br /></td></tr>
<tr class="separator:ga8658f18b6b0489c1dafa4903c64c0165"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa8d770560279dcdaa48764810b77c30d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__AABBTreeGroup.html#gaa8d770560279dcdaa48764810b77c30d">MR::isInside</a> (const <a class="el" href="namespaceMR.html#ab1ca9892644603a8b29005353e5ada79">Polyline2</a> &amp;a, const <a class="el" href="namespaceMR.html#ab1ca9892644603a8b29005353e5ada79">Polyline2</a> &amp;b, const <a class="el" href="namespaceMR.html#aaf5a1eb99830c5d7196aa5bf3a05f70e">AffineXf2f</a> *rigidB2A=nullptr)</td></tr>
<tr class="memdesc:gaa8d770560279dcdaa48764810b77c30d"><td class="mdescLeft">&#160;</td><td class="mdescRight">checks that arbitrary 2d polyline A is inside of closed 2d polyline B  <br /></td></tr>
<tr class="separator:gaa8d770560279dcdaa48764810b77c30d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2aba3040bbdbbafb7d8e38803b955524"><td class="memItemLeft" align="right" valign="top"><a class="el" href="MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__AABBTreeGroup.html#ga2aba3040bbdbbafb7d8e38803b955524">MR::isPointInsidePolyline</a> (const <a class="el" href="namespaceMR.html#ab1ca9892644603a8b29005353e5ada79">Polyline2</a> &amp;polyline, const <a class="el" href="namespaceMR.html#a61594f31bab4ef06a3f164c0199198e7">Vector2f</a> &amp;point)</td></tr>
<tr class="memdesc:ga2aba3040bbdbbafb7d8e38803b955524"><td class="mdescLeft">&#160;</td><td class="mdescRight">detect if given point is inside polyline, by counting ray intersections  <br /></td></tr>
<tr class="separator:ga2aba3040bbdbbafb7d8e38803b955524"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7f7211a85409018fd8ee71495646faa3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> <a class="el" href="namespaceMR.html#a0898ca7d08b2fb73875b21bf4921f4fd">PolylineProjectionResult2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__AABBTreeGroup.html#ga7f7211a85409018fd8ee71495646faa3">MR::findProjectionOnPolyline2</a> (const <a class="el" href="namespaceMR.html#a61594f31bab4ef06a3f164c0199198e7">Vector2f</a> &amp;pt, const <a class="el" href="namespaceMR.html#ab1ca9892644603a8b29005353e5ada79">Polyline2</a> &amp;polyline, float upDistLimitSq=FLT_MAX, <a class="el" href="namespaceMR.html#aaf5a1eb99830c5d7196aa5bf3a05f70e">AffineXf2f</a> *xf=nullptr, float loDistLimitSq=0)</td></tr>
<tr class="memdesc:ga7f7211a85409018fd8ee71495646faa3"><td class="mdescLeft">&#160;</td><td class="mdescRight">computes the closest point on polyline to given point  <br /></td></tr>
<tr class="separator:ga7f7211a85409018fd8ee71495646faa3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5e71a300face382a26ba8596d9b19820"><td class="memItemLeft" align="right" valign="top"><a class="el" href="MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> <a class="el" href="namespaceMR.html#a847af1551a9dcab4a5a333b6607522a7">PolylineProjectionResult3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__AABBTreeGroup.html#ga5e71a300face382a26ba8596d9b19820">MR::findProjectionOnPolyline</a> (const <a class="el" href="namespaceMR.html#a5f4a954ba7d1785cafcb2f7ffe7acf09">Vector3f</a> &amp;pt, const <a class="el" href="namespaceMR.html#a58b74f27c86e7e9dee889bfe30f3022a">Polyline3</a> &amp;polyline, float upDistLimitSq=FLT_MAX, <a class="el" href="namespaceMR.html#a9cf4b064aa13c5becce6312228c3c03b">AffineXf3f</a> *xf=nullptr, float loDistLimitSq=0)</td></tr>
<tr class="memdesc:ga5e71a300face382a26ba8596d9b19820"><td class="mdescLeft">&#160;</td><td class="mdescRight">computes the closest point on polyline to given point  <br /></td></tr>
<tr class="separator:ga5e71a300face382a26ba8596d9b19820"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa484a0628a7ac3858cd590589687141c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> <a class="el" href="namespaceMR.html#a847af1551a9dcab4a5a333b6607522a7">PolylineProjectionResult3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__AABBTreeGroup.html#gaa484a0628a7ac3858cd590589687141c">MR::findProjectionOnPolyline</a> (const <a class="el" href="namespaceMR.html#acfd96aa6798933e1a002144fb0dc22af">Line3f</a> &amp;ln, const <a class="el" href="namespaceMR.html#a58b74f27c86e7e9dee889bfe30f3022a">Polyline3</a> &amp;polyline, float upDistLimitSq=FLT_MAX, <a class="el" href="namespaceMR.html#a9cf4b064aa13c5becce6312228c3c03b">AffineXf3f</a> *xf=nullptr, float loDistLimitSq=0)</td></tr>
<tr class="memdesc:gaa484a0628a7ac3858cd590589687141c"><td class="mdescLeft">&#160;</td><td class="mdescRight">computes the closest point on polyline to given straight line  <br /></td></tr>
<tr class="separator:gaa484a0628a7ac3858cd590589687141c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf2ef419d4414bb6d0efa0c918b21bddf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> <a class="el" href="namespaceMR.html#aa9c24bbb5a16bcc2d1385bdbd2340aae">Polyline2ProjectionWithOffsetResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__AABBTreeGroup.html#gaf2ef419d4414bb6d0efa0c918b21bddf">MR::findProjectionOnPolyline2WithOffset</a> (const <a class="el" href="namespaceMR.html#a61594f31bab4ef06a3f164c0199198e7">Vector2f</a> &amp;pt, const <a class="el" href="namespaceMR.html#ab1ca9892644603a8b29005353e5ada79">Polyline2</a> &amp;polyline, const <a class="el" href="classMR_1_1Vector.html">Vector</a>&lt; float, <a class="el" href="namespaceMR.html#a65798dca01178b50da3bbd7968fb360e">UndirectedEdgeId</a> &gt; &amp;offsetPerEdge, float upDistLimit=FLT_MAX, <a class="el" href="namespaceMR.html#aaf5a1eb99830c5d7196aa5bf3a05f70e">AffineXf2f</a> *xf=nullptr, float loDistLimit=0)</td></tr>
<tr class="memdesc:gaf2ef419d4414bb6d0efa0c918b21bddf"><td class="mdescLeft">&#160;</td><td class="mdescRight">computes the closest point on polyline to given point, respecting each edge offset  <br /></td></tr>
<tr class="separator:gaf2ef419d4414bb6d0efa0c918b21bddf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga834d7e50b54b1b8c511990fc9d14c09c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> <a class="el" href="namespaceMR.html#a2488a5918dcbf78bcbf511ea6c93a185">PolylineProjectionWithOffsetResult3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__AABBTreeGroup.html#ga834d7e50b54b1b8c511990fc9d14c09c">MR::findProjectionOnPolylineWithOffset</a> (const <a class="el" href="namespaceMR.html#a5f4a954ba7d1785cafcb2f7ffe7acf09">Vector3f</a> &amp;pt, const <a class="el" href="namespaceMR.html#a58b74f27c86e7e9dee889bfe30f3022a">Polyline3</a> &amp;polyline, const <a class="el" href="classMR_1_1Vector.html">Vector</a>&lt; float, <a class="el" href="namespaceMR.html#a65798dca01178b50da3bbd7968fb360e">UndirectedEdgeId</a> &gt; &amp;offsetPerEdge, float upDistLimit=FLT_MAX, <a class="el" href="namespaceMR.html#a9cf4b064aa13c5becce6312228c3c03b">AffineXf3f</a> *xf=nullptr, float loDistLimit=0)</td></tr>
<tr class="memdesc:ga834d7e50b54b1b8c511990fc9d14c09c"><td class="mdescLeft">&#160;</td><td class="mdescRight">computes the closest point on polyline to given point, respecting each edge offset  <br /></td></tr>
<tr class="separator:ga834d7e50b54b1b8c511990fc9d14c09c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5ce436376c8036ec99459d3ccea88788"><td class="memItemLeft" align="right" valign="top"><a class="el" href="MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__AABBTreeGroup.html#ga5ce436376c8036ec99459d3ccea88788">MR::findEdgesInBall</a> (const <a class="el" href="namespaceMR.html#ab1ca9892644603a8b29005353e5ada79">Polyline2</a> &amp;polyline, const <a class="el" href="namespaceMR.html#a61594f31bab4ef06a3f164c0199198e7">Vector2f</a> &amp;center, float radius, const <a class="el" href="group__AABBTreeGroup.html#ga4f844f73b163343e67f73579ee60eb3b">FoundEdgeCallback2</a> &amp;foundCallback, <a class="el" href="namespaceMR.html#aaf5a1eb99830c5d7196aa5bf3a05f70e">AffineXf2f</a> *xf=nullptr)</td></tr>
<tr class="memdesc:ga5ce436376c8036ec99459d3ccea88788"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds all edges of given polyline that cross or touch given ball (center, radius)  <br /></td></tr>
<tr class="separator:ga5ce436376c8036ec99459d3ccea88788"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga799578a1ff64417ca5aa5c72fa15bb2f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__AABBTreeGroup.html#ga799578a1ff64417ca5aa5c72fa15bb2f">MR::findEdgesInBall</a> (const <a class="el" href="namespaceMR.html#a58b74f27c86e7e9dee889bfe30f3022a">Polyline3</a> &amp;polyline, const <a class="el" href="namespaceMR.html#a5f4a954ba7d1785cafcb2f7ffe7acf09">Vector3f</a> &amp;center, float radius, const <a class="el" href="group__AABBTreeGroup.html#gaf77c51a2927a660589bbe050fdbd6ac8">FoundEdgeCallback3</a> &amp;foundCallback, <a class="el" href="namespaceMR.html#a9cf4b064aa13c5becce6312228c3c03b">AffineXf3f</a> *xf=nullptr)</td></tr>
<tr class="memdesc:ga799578a1ff64417ca5aa5c72fa15bb2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds all edges of given polyline that cross or touch given ball (center, radius)  <br /></td></tr>
<tr class="separator:ga799578a1ff64417ca5aa5c72fa15bb2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga50911249a881bd7365929503c138d8fa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__AABBTreeGroup.html#ga50911249a881bd7365929503c138d8fa">MR::findMeshEdgesInBall</a> (const <a class="el" href="structMR_1_1Mesh.html">Mesh</a> &amp;mesh, const <a class="el" href="namespaceMR.html#aef16e8bcd64e7d95e00ad05f1a333c43">AABBTreePolyline3</a> &amp;tree, const <a class="el" href="namespaceMR.html#a5f4a954ba7d1785cafcb2f7ffe7acf09">Vector3f</a> &amp;center, float radius, const <a class="el" href="group__AABBTreeGroup.html#gaf77c51a2927a660589bbe050fdbd6ac8">FoundEdgeCallback3</a> &amp;foundCallback, <a class="el" href="namespaceMR.html#a9cf4b064aa13c5becce6312228c3c03b">AffineXf3f</a> *xf=nullptr)</td></tr>
<tr class="memdesc:ga50911249a881bd7365929503c138d8fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds all edges of given mesh edges (specified by the tree) that cross or touch given ball (center, radius)  <br /></td></tr>
<tr class="separator:ga50911249a881bd7365929503c138d8fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga64c37b9a7a04aa567390955a50891b57"><td class="memItemLeft" align="right" valign="top"><a class="el" href="MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> <a class="el" href="namespaceMR.html#a847af1551a9dcab4a5a333b6607522a7">PolylineProjectionResult3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__AABBTreeGroup.html#ga64c37b9a7a04aa567390955a50891b57">MR::findProjectionOnMeshEdges</a> (const <a class="el" href="namespaceMR.html#a5f4a954ba7d1785cafcb2f7ffe7acf09">Vector3f</a> &amp;pt, const <a class="el" href="structMR_1_1Mesh.html">Mesh</a> &amp;mesh, const <a class="el" href="namespaceMR.html#aef16e8bcd64e7d95e00ad05f1a333c43">AABBTreePolyline3</a> &amp;tree, float upDistLimitSq=FLT_MAX, <a class="el" href="namespaceMR.html#a9cf4b064aa13c5becce6312228c3c03b">AffineXf3f</a> *xf=nullptr, float loDistLimitSq=0)</td></tr>
<tr class="memdesc:ga64c37b9a7a04aa567390955a50891b57"><td class="mdescLeft">&#160;</td><td class="mdescRight">computes the closest point on the mesh edges (specified by the tree) to given point  <br /></td></tr>
<tr class="separator:ga64c37b9a7a04aa567390955a50891b57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaccdf7712b3c2bc175e4b09aae138aa40"><td class="memItemLeft" align="right" valign="top"><a class="el" href="MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> <a class="el" href="namespaceMR.html#a847af1551a9dcab4a5a333b6607522a7">PolylineProjectionResult3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__AABBTreeGroup.html#gaccdf7712b3c2bc175e4b09aae138aa40">MR::findProjectionOnMeshEdges</a> (const <a class="el" href="namespaceMR.html#acfd96aa6798933e1a002144fb0dc22af">Line3f</a> &amp;ln, const <a class="el" href="structMR_1_1Mesh.html">Mesh</a> &amp;mesh, const <a class="el" href="namespaceMR.html#aef16e8bcd64e7d95e00ad05f1a333c43">AABBTreePolyline3</a> &amp;tree, float upDistLimitSq=FLT_MAX, <a class="el" href="namespaceMR.html#a9cf4b064aa13c5becce6312228c3c03b">AffineXf3f</a> *xf=nullptr, float loDistLimitSq=0)</td></tr>
<tr class="memdesc:gaccdf7712b3c2bc175e4b09aae138aa40"><td class="mdescLeft">&#160;</td><td class="mdescRight">computes the closest point on the mesh edges (specified by the tree) to given straight line  <br /></td></tr>
<tr class="separator:gaccdf7712b3c2bc175e4b09aae138aa40"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ga5e3f58e5a000086f4df8523da65c9b4f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structMR_1_1Vector3.html">Vector3</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__AABBTreeGroup.html#ga5e3f58e5a000086f4df8523da65c9b4f">MR::IntersectionPrecomputes&lt; T &gt;::invDir</a></td></tr>
<tr class="separator:ga5e3f58e5a000086f4df8523da65c9b4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaffa5bcb7a516c4dda421ace86e2597c2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__AABBTreeGroup.html#gaffa5bcb7a516c4dda421ace86e2597c2">MR::IntersectionPrecomputes&lt; T &gt;::maxDimIdxZ</a> = 2</td></tr>
<tr class="separator:gaffa5bcb7a516c4dda421ace86e2597c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga59240ce19dcf5b27221a347b22086fcb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__AABBTreeGroup.html#ga59240ce19dcf5b27221a347b22086fcb">MR::IntersectionPrecomputes&lt; T &gt;::idxX</a> = 0</td></tr>
<tr class="separator:ga59240ce19dcf5b27221a347b22086fcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1e89bb11cf7c4693e1c8839963994a08"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__AABBTreeGroup.html#ga1e89bb11cf7c4693e1c8839963994a08">MR::IntersectionPrecomputes&lt; T &gt;::idxY</a> = 1</td></tr>
<tr class="separator:ga1e89bb11cf7c4693e1c8839963994a08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga28372a635ba67b43220bc9067be6560d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceMR.html#af24b71b1cf7ac2e3a63c2d988fd599f0">Vector3i</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__AABBTreeGroup.html#ga28372a635ba67b43220bc9067be6560d">MR::IntersectionPrecomputes&lt; T &gt;::sign</a></td></tr>
<tr class="memdesc:ga28372a635ba67b43220bc9067be6560d"><td class="mdescLeft">&#160;</td><td class="mdescRight">stores signs of direction vector;  <br /></td></tr>
<tr class="separator:ga28372a635ba67b43220bc9067be6560d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga21465bc7d67177777744f39ac171940c"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__AABBTreeGroup.html#ga21465bc7d67177777744f39ac171940c">MR::IntersectionPrecomputes&lt; T &gt;::Sx</a></td></tr>
<tr class="memdesc:ga21465bc7d67177777744f39ac171940c"><td class="mdescLeft">&#160;</td><td class="mdescRight">precomputed factors  <br /></td></tr>
<tr class="separator:ga21465bc7d67177777744f39ac171940c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf95502c89221bba3187782d4ed18199b"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__AABBTreeGroup.html#gaf95502c89221bba3187782d4ed18199b">MR::IntersectionPrecomputes&lt; T &gt;::Sy</a></td></tr>
<tr class="separator:gaf95502c89221bba3187782d4ed18199b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6159c869b0afc38ccf26091c1681194a"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__AABBTreeGroup.html#ga6159c869b0afc38ccf26091c1681194a">MR::IntersectionPrecomputes&lt; T &gt;::Sz</a></td></tr>
<tr class="separator:ga6159c869b0afc38ccf26091c1681194a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>This chapter represents documentation about AABB Tree. </p>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ga34a8bbcd6701c78c61502a42e3a1dca0" name="ga34a8bbcd6701c78c61502a42e3a1dca0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga34a8bbcd6701c78c61502a42e3a1dca0">&#9670;&#160;</a></span>AABBTreeNodeId</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__AABBTreeGroup.html#ga34a8bbcd6701c78c61502a42e3a1dca0">MR::AABBTreeNodeId</a> = typedef typename <a class="el" href="structMR_1_1AABBTreeNode.html">AABBTreeNode</a>&lt;T&gt;::NodeId</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga0dc29c20db23419ffc06b5a3a0244204" name="ga0dc29c20db23419ffc06b5a3a0244204"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0dc29c20db23419ffc06b5a3a0244204">&#9670;&#160;</a></span>AABBTreeNodeVec</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__AABBTreeGroup.html#ga0dc29c20db23419ffc06b5a3a0244204">MR::AABBTreeNodeVec</a> = typedef <a class="el" href="classMR_1_1Vector.html">Vector</a>&lt;<a class="el" href="structMR_1_1AABBTreeNode.html">AABBTreeNode</a>&lt;T&gt;, <a class="el" href="group__AABBTreeGroup.html#ga34a8bbcd6701c78c61502a42e3a1dca0">AABBTreeNodeId</a>&lt;T&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga4835cdcf7f575fd6b4381c29fc920269" name="ga4835cdcf7f575fd6b4381c29fc920269"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4835cdcf7f575fd6b4381c29fc920269">&#9670;&#160;</a></span>ConvertToFloatVector</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__AABBTreeGroup.html#ga4835cdcf7f575fd6b4381c29fc920269">MR::ConvertToFloatVector</a> = typedef std::function&lt;<a class="el" href="namespaceMR.html#a5f4a954ba7d1785cafcb2f7ffe7acf09">Vector3f</a>( const <a class="el" href="namespaceMR.html#af24b71b1cf7ac2e3a63c2d988fd599f0">Vector3i</a>&amp; )&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>int-to-float coordinate converter </p>

</div>
</div>
<a id="gaa1341f2eec34b89f628200697d1c55a1" name="gaa1341f2eec34b89f628200697d1c55a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa1341f2eec34b89f628200697d1c55a1">&#9670;&#160;</a></span>ConvertToIntVector</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__AABBTreeGroup.html#gaa1341f2eec34b89f628200697d1c55a1">MR::ConvertToIntVector</a> = typedef std::function&lt;<a class="el" href="namespaceMR.html#af24b71b1cf7ac2e3a63c2d988fd599f0">Vector3i</a>(const <a class="el" href="namespaceMR.html#a5f4a954ba7d1785cafcb2f7ffe7acf09">Vector3f</a>&amp;)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>float-to-int coordinate converter </p>

</div>
</div>
<a id="gad692565ba80610283f4322d081a95ef8" name="gad692565ba80610283f4322d081a95ef8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad692565ba80610283f4322d081a95ef8">&#9670;&#160;</a></span>FaceTreeTraits3</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__AABBTreeGroup.html#gad692565ba80610283f4322d081a95ef8">MR::FaceTreeTraits3</a> = typedef <a class="el" href="structMR_1_1ABBTreeTraits.html">ABBTreeTraits</a>&lt;<a class="el" href="namespaceMR.html#a4234a65e90443b87f6412b4e681a38ac">FaceId</a>, <a class="el" href="namespaceMR.html#ada98ebf3fec74759dd46700389a3e556">Box3f</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga6567418169a65826fd82b440411a4fc4" name="ga6567418169a65826fd82b440411a4fc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6567418169a65826fd82b440411a4fc4">&#9670;&#160;</a></span>FoundEdgeCallback</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename V &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__AABBTreeGroup.html#ga6567418169a65826fd82b440411a4fc4">MR::FoundEdgeCallback</a> = typedef std::function&lt;void( <a class="el" href="namespaceMR.html#a65798dca01178b50da3bbd7968fb360e">UndirectedEdgeId</a>, const V&amp; closestPt, float distSq )&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga4f844f73b163343e67f73579ee60eb3b" name="ga4f844f73b163343e67f73579ee60eb3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4f844f73b163343e67f73579ee60eb3b">&#9670;&#160;</a></span>FoundEdgeCallback2</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__AABBTreeGroup.html#ga4f844f73b163343e67f73579ee60eb3b">MR::FoundEdgeCallback2</a> = typedef <a class="el" href="group__AABBTreeGroup.html#ga6567418169a65826fd82b440411a4fc4">FoundEdgeCallback</a>&lt;<a class="el" href="namespaceMR.html#a61594f31bab4ef06a3f164c0199198e7">Vector2f</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="gaf77c51a2927a660589bbe050fdbd6ac8" name="gaf77c51a2927a660589bbe050fdbd6ac8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf77c51a2927a660589bbe050fdbd6ac8">&#9670;&#160;</a></span>FoundEdgeCallback3</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__AABBTreeGroup.html#gaf77c51a2927a660589bbe050fdbd6ac8">MR::FoundEdgeCallback3</a> = typedef <a class="el" href="group__AABBTreeGroup.html#ga6567418169a65826fd82b440411a4fc4">FoundEdgeCallback</a>&lt;<a class="el" href="namespaceMR.html#a5f4a954ba7d1785cafcb2f7ffe7acf09">Vector3f</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="gaaf317c41824870416408c08346c2171e" name="gaaf317c41824870416408c08346c2171e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaf317c41824870416408c08346c2171e">&#9670;&#160;</a></span>Line3dMesh</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__AABBTreeGroup.html#gaaf317c41824870416408c08346c2171e">MR::Line3dMesh</a> = typedef <a class="el" href="structMR_1_1Line3Mesh.html">Line3Mesh</a>&lt;double&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga5ab271790117f87421a1332a6c3e9d95" name="ga5ab271790117f87421a1332a6c3e9d95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5ab271790117f87421a1332a6c3e9d95">&#9670;&#160;</a></span>Line3fMesh</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__AABBTreeGroup.html#ga5ab271790117f87421a1332a6c3e9d95">MR::Line3fMesh</a> = typedef <a class="el" href="structMR_1_1Line3Mesh.html">Line3Mesh</a>&lt;float&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga17af3e1b79216c9f09669326d43cf22d" name="ga17af3e1b79216c9f09669326d43cf22d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga17af3e1b79216c9f09669326d43cf22d">&#9670;&#160;</a></span>LineTreeTraits</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename V &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__AABBTreeGroup.html#ga17af3e1b79216c9f09669326d43cf22d">MR::LineTreeTraits</a> = typedef <a class="el" href="structMR_1_1ABBTreeTraits.html">ABBTreeTraits</a>&lt;<a class="el" href="namespaceMR.html#a65798dca01178b50da3bbd7968fb360e">UndirectedEdgeId</a>, <a class="el" href="structMR_1_1Box.html">Box</a>&lt;V&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="gae0095cba19362d8f40a9beaedc20b142" name="gae0095cba19362d8f40a9beaedc20b142"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae0095cba19362d8f40a9beaedc20b142">&#9670;&#160;</a></span>LineTreeTraits2</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__AABBTreeGroup.html#gae0095cba19362d8f40a9beaedc20b142">MR::LineTreeTraits2</a> = typedef <a class="el" href="group__AABBTreeGroup.html#ga17af3e1b79216c9f09669326d43cf22d">LineTreeTraits</a>&lt;<a class="el" href="namespaceMR.html#a61594f31bab4ef06a3f164c0199198e7">Vector2f</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga9e0548c1f8dc47ae420a227a56165c7c" name="ga9e0548c1f8dc47ae420a227a56165c7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9e0548c1f8dc47ae420a227a56165c7c">&#9670;&#160;</a></span>LineTreeTraits3</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__AABBTreeGroup.html#ga9e0548c1f8dc47ae420a227a56165c7c">MR::LineTreeTraits3</a> = typedef <a class="el" href="group__AABBTreeGroup.html#ga17af3e1b79216c9f09669326d43cf22d">LineTreeTraits</a>&lt;<a class="el" href="namespaceMR.html#a5f4a954ba7d1785cafcb2f7ffe7acf09">Vector3f</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="gab84b0b767274335b6f0f59bbb9537fe3" name="gab84b0b767274335b6f0f59bbb9537fe3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab84b0b767274335b6f0f59bbb9537fe3">&#9670;&#160;</a></span>MeshIntersectionCallback</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__AABBTreeGroup.html#gab84b0b767274335b6f0f59bbb9537fe3">MR::MeshIntersectionCallback</a> = typedef std::function&lt;bool(const <a class="el" href="structMR_1_1MeshIntersectionResult.html">MeshIntersectionResult</a> &amp;)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>this callback is envoked for each encountered ray-mesh intersection; if it returns false, then the search immediately terminates </p>

</div>
</div>
<a id="ga163d12cc5f6452ebe26a959afb1d5379" name="ga163d12cc5f6452ebe26a959afb1d5379"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga163d12cc5f6452ebe26a959afb1d5379">&#9670;&#160;</a></span>TriangleCallback</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__AABBTreeGroup.html#ga163d12cc5f6452ebe26a959afb1d5379">MR::TriangleCallback</a> = typedef std::function&lt;<a class="el" href="group__AABBTreeGroup.html#ga3dd2fd9fcc06b6502d22a9ea3eb63e47">ProcessOneResult</a>( const <a class="el" href="namespaceMR.html#a5f4a954ba7d1785cafcb2f7ffe7acf09">Vector3f</a> &amp; p, <a class="el" href="namespaceMR.html#a4234a65e90443b87f6412b4e681a38ac">FaceId</a> f, const <a class="el" href="namespaceMR.html#a5f4a954ba7d1785cafcb2f7ffe7acf09">Vector3f</a> &amp; q, float distSq )&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>this callback is invoked for every triangle in range, where </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>closest point on original triangle </td></tr>
    <tr><td class="paramname">f</td><td>triangle id in question </td></tr>
    <tr><td class="paramname">q</td><td>closest point on f-triangle </td></tr>
    <tr><td class="paramname">distSq</td><td>squared distance in between p and q </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>whether to continue or to stop processing other triangles </dd></dl>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ga3dd2fd9fcc06b6502d22a9ea3eb63e47" name="ga3dd2fd9fcc06b6502d22a9ea3eb63e47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3dd2fd9fcc06b6502d22a9ea3eb63e47">&#9670;&#160;</a></span>ProcessOneResult</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="group__AABBTreeGroup.html#ga3dd2fd9fcc06b6502d22a9ea3eb63e47">MR::ProcessOneResult</a> : bool</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga3dd2fd9fcc06b6502d22a9ea3eb63e47a38e59feb928e37292c8ee0a50f447612" name="gga3dd2fd9fcc06b6502d22a9ea3eb63e47a38e59feb928e37292c8ee0a50f447612"></a>StopProcessing&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="gga3dd2fd9fcc06b6502d22a9ea3eb63e47aab6bb60f51b25ae0f7ec450173e3348e" name="gga3dd2fd9fcc06b6502d22a9ea3eb63e47aab6bb60f51b25ae0f7ec450173e3348e"></a>ContinueProcessing&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga15a3e18d2098f8ff33e67776a221e6fb" name="ga15a3e18d2098f8ff33e67776a221e6fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga15a3e18d2098f8ff33e67776a221e6fb">&#9670;&#160;</a></span>findCollidingEdgePairs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> std::vector&lt; <a class="el" href="structMR_1_1EdgePointPair.html">EdgePointPair</a> &gt; MR::findCollidingEdgePairs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceMR.html#ab1ca9892644603a8b29005353e5ada79">Polyline2</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceMR.html#ab1ca9892644603a8b29005353e5ada79">Polyline2</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceMR.html#aaf5a1eb99830c5d7196aa5bf3a05f70e">AffineXf2f</a> *&#160;</td>
          <td class="paramname"><em>rigidB2A</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>firstIntersectionOnly</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>finds all pairs of colliding edges from two 2d polylines </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rigidB2A</td><td>rigid transformation from B-polyline space to A polyline space, nullptr considered as identity transformation </td></tr>
    <tr><td class="paramname">firstIntersectionOnly</td><td>if true then the function returns at most one pair of intersecting edges and returns faster </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga44c8af10ceaf3059a77647d7b6f2ca8b" name="ga44c8af10ceaf3059a77647d7b6f2ca8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga44c8af10ceaf3059a77647d7b6f2ca8b">&#9670;&#160;</a></span>findCollidingEdges()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> std::vector&lt; <a class="el" href="structMR_1_1UndirectedEdgeUndirectedEdge.html">UndirectedEdgeUndirectedEdge</a> &gt; MR::findCollidingEdges </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceMR.html#ab1ca9892644603a8b29005353e5ada79">Polyline2</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceMR.html#ab1ca9892644603a8b29005353e5ada79">Polyline2</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceMR.html#aaf5a1eb99830c5d7196aa5bf3a05f70e">AffineXf2f</a> *&#160;</td>
          <td class="paramname"><em>rigidB2A</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>firstIntersectionOnly</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>finds all pairs of colliding edges from two 2d polylines </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rigidB2A</td><td>rigid transformation from B-polyline space to A polyline space, nullptr considered as identity transformation </td></tr>
    <tr><td class="paramname">firstIntersectionOnly</td><td>if true then the function returns at most one pair of intersecting edges and returns faster </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga0f3404724c88f935957c8c3c8962ea3a" name="ga0f3404724c88f935957c8c3c8962ea3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0f3404724c88f935957c8c3c8962ea3a">&#9670;&#160;</a></span>findCollidingEdgesBitsets()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> std::pair&lt; <a class="el" href="namespaceMR.html#ae5a4467feb7b60cd337643529597aaaa">UndirectedEdgeBitSet</a>, <a class="el" href="namespaceMR.html#ae5a4467feb7b60cd337643529597aaaa">UndirectedEdgeBitSet</a> &gt; MR::findCollidingEdgesBitsets </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceMR.html#ab1ca9892644603a8b29005353e5ada79">Polyline2</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceMR.html#ab1ca9892644603a8b29005353e5ada79">Polyline2</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceMR.html#aaf5a1eb99830c5d7196aa5bf3a05f70e">AffineXf2f</a> *&#160;</td>
          <td class="paramname"><em>rigidB2A</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>finds bitset per polyline with colliding edges </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rigidB2A</td><td>rigid transformation from B-polyline space to A polyline space, nullptr considered as identity transformation </td></tr>
    <tr><td class="paramname">firstIntersectionOnly</td><td>if true then the function returns at most one pair of intersecting edges and returns faster </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga8c7d357b072699f62023d97ea1c81f45" name="ga8c7d357b072699f62023d97ea1c81f45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8c7d357b072699f62023d97ea1c81f45">&#9670;&#160;</a></span>findCollidingEdgeTrisPrecise() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> std::vector&lt; <a class="el" href="structMR_1_1EdgeTri.html">EdgeTri</a> &gt; MR::findCollidingEdgeTrisPrecise </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structMR_1_1Mesh.html">Mesh</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespaceMR.html#a82c7618d8fb2b9dd9a8c5ea89be1b0f1">EdgeId</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>edgesA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structMR_1_1Mesh.html">Mesh</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespaceMR.html#a4234a65e90443b87f6412b4e681a38ac">FaceId</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>facesB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__AABBTreeGroup.html#gaa1341f2eec34b89f628200697d1c55a1">ConvertToIntVector</a>&#160;</td>
          <td class="paramname"><em>conv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceMR.html#a9cf4b064aa13c5becce6312228c3c03b">AffineXf3f</a> *&#160;</td>
          <td class="paramname"><em>rigidB2A</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>finds all intersections between every given edge from A and given triangles from B </p>

</div>
</div>
<a id="ga939afe34134c1d66c9ca5f19e33dc323" name="ga939afe34134c1d66c9ca5f19e33dc323"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga939afe34134c1d66c9ca5f19e33dc323">&#9670;&#160;</a></span>findCollidingEdgeTrisPrecise() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> std::vector&lt; <a class="el" href="structMR_1_1EdgeTri.html">EdgeTri</a> &gt; MR::findCollidingEdgeTrisPrecise </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structMR_1_1Mesh.html">Mesh</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespaceMR.html#a4234a65e90443b87f6412b4e681a38ac">FaceId</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>facesA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structMR_1_1Mesh.html">Mesh</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespaceMR.html#a82c7618d8fb2b9dd9a8c5ea89be1b0f1">EdgeId</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>edgesB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__AABBTreeGroup.html#gaa1341f2eec34b89f628200697d1c55a1">ConvertToIntVector</a>&#160;</td>
          <td class="paramname"><em>conv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceMR.html#a9cf4b064aa13c5becce6312228c3c03b">AffineXf3f</a> *&#160;</td>
          <td class="paramname"><em>rigidB2A</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>finds all intersections between every given triangle from A and given edge from B </p>

</div>
</div>
<a id="ga11d4ca955f1a62e15ebea578ffa83454" name="ga11d4ca955f1a62e15ebea578ffa83454"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga11d4ca955f1a62e15ebea578ffa83454">&#9670;&#160;</a></span>findCollidingEdgeTrisPrecise() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> <a class="el" href="structMR_1_1PreciseCollisionResult.html">PreciseCollisionResult</a> MR::findCollidingEdgeTrisPrecise </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structMR_1_1MeshPart.html">MeshPart</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structMR_1_1MeshPart.html">MeshPart</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__AABBTreeGroup.html#gaa1341f2eec34b89f628200697d1c55a1">ConvertToIntVector</a>&#160;</td>
          <td class="paramname"><em>conv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceMR.html#a9cf4b064aa13c5becce6312228c3c03b">AffineXf3f</a> *&#160;</td>
          <td class="paramname"><em>rigidB2A</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>anyIntersection</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>finds all pairs of colliding edges from one mesh and triangle from another mesh </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rigidB2A</td><td>rigid transformation from B-mesh space to A mesh space, nullptr considered as identity transformation </td></tr>
    <tr><td class="paramname">anyIntersection</td><td>if true then the function returns as fast as it finds any intersection </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga47e983a2ba53dbe6d49313488f3cae23" name="ga47e983a2ba53dbe6d49313488f3cae23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga47e983a2ba53dbe6d49313488f3cae23">&#9670;&#160;</a></span>findCollidingTriangleBitsets()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> std::pair&lt; <a class="el" href="namespaceMR.html#a0e5b61f8edf7a896c3f2f4a6eeb4691d">FaceBitSet</a>, <a class="el" href="namespaceMR.html#a0e5b61f8edf7a896c3f2f4a6eeb4691d">FaceBitSet</a> &gt; MR::findCollidingTriangleBitsets </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structMR_1_1MeshPart.html">MeshPart</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structMR_1_1MeshPart.html">MeshPart</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceMR.html#a9cf4b064aa13c5becce6312228c3c03b">AffineXf3f</a> *&#160;</td>
          <td class="paramname"><em>rigidB2A</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>the same as <a class="el" href="group__AABBTreeGroup.html#gaaeb209f0c917451a03debbf058fc39e6">findCollidingTriangles</a>, but returns one bite set per mesh with colliding triangles </p>

</div>
</div>
<a id="gaaeb209f0c917451a03debbf058fc39e6" name="gaaeb209f0c917451a03debbf058fc39e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaeb209f0c917451a03debbf058fc39e6">&#9670;&#160;</a></span>findCollidingTriangles()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> std::vector&lt; <a class="el" href="structMR_1_1FaceFace.html">FaceFace</a> &gt; MR::findCollidingTriangles </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structMR_1_1MeshPart.html">MeshPart</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structMR_1_1MeshPart.html">MeshPart</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceMR.html#a9cf4b064aa13c5becce6312228c3c03b">AffineXf3f</a> *&#160;</td>
          <td class="paramname"><em>rigidB2A</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>firstIntersectionOnly</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>finds all pairs of colliding triangles from two meshes or two mesh regions </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rigidB2A</td><td>rigid transformation from B-mesh space to A mesh space, nullptr considered as identity transformation </td></tr>
    <tr><td class="paramname">firstIntersectionOnly</td><td>if true then the function returns at most one pair of intersecting triangles and returns faster </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf49d29fe114a45e7ba44769ed23e07a7" name="gaf49d29fe114a45e7ba44769ed23e07a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf49d29fe114a45e7ba44769ed23e07a7">&#9670;&#160;</a></span>findDirMax()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> <a class="el" href="namespaceMR.html#a2f4408b5ff9250509a9d18a04d6f1fb5">VertId</a> MR::findDirMax </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceMR.html#a5f4a954ba7d1785cafcb2f7ffe7acf09">Vector3f</a> &amp;&#160;</td>
          <td class="paramname"><em>dir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structMR_1_1MeshPart.html">MeshPart</a> &amp;&#160;</td>
          <td class="paramname"><em>mp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceMR.html#afb67fe49bcb6006882e7b08e51b2eeff">UseAABBTree</a>&#160;</td>
          <td class="paramname"><em>u</em> = <code><a class="el" href="namespaceMR.html#afb67fe49bcb6006882e7b08e51b2eeffa93cba07454f06a4a960172bbd6e2a435">UseAABBTree::Yes</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>finds the vertex in the mesh part having the largest projection on given direction, uses aabb-tree inside for faster computation </p>

</div>
</div>
<a id="gae8acc67c54f5f060c954bb3528a0c581" name="gae8acc67c54f5f060c954bb3528a0c581"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae8acc67c54f5f060c954bb3528a0c581">&#9670;&#160;</a></span>findDistance()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> <a class="el" href="structMR_1_1MeshDistanceResult.html">MeshDistanceResult</a> MR::findDistance </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structMR_1_1MeshPart.html">MeshPart</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structMR_1_1MeshPart.html">MeshPart</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceMR.html#a9cf4b064aa13c5becce6312228c3c03b">AffineXf3f</a> *&#160;</td>
          <td class="paramname"><em>rigidB2A</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>upDistLimitSq</em> = <code>FLT_MAX</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>computes minimal distance between two meshes or two mesh regions </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rigidB2A</td><td>rigid transformation from B-mesh space to A mesh space, nullptr considered as identity transformation </td></tr>
    <tr><td class="paramname">upDistLimitSq</td><td>upper limit on the distance in question, if the real distance is larger than the function exists returning upDistLimitSq and no valid points </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga5ce436376c8036ec99459d3ccea88788" name="ga5ce436376c8036ec99459d3ccea88788"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5ce436376c8036ec99459d3ccea88788">&#9670;&#160;</a></span>findEdgesInBall() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> void MR::findEdgesInBall </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceMR.html#ab1ca9892644603a8b29005353e5ada79">Polyline2</a> &amp;&#160;</td>
          <td class="paramname"><em>polyline</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceMR.html#a61594f31bab4ef06a3f164c0199198e7">Vector2f</a> &amp;&#160;</td>
          <td class="paramname"><em>center</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__AABBTreeGroup.html#ga4f844f73b163343e67f73579ee60eb3b">FoundEdgeCallback2</a> &amp;&#160;</td>
          <td class="paramname"><em>foundCallback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceMR.html#aaf5a1eb99830c5d7196aa5bf3a05f70e">AffineXf2f</a> *&#160;</td>
          <td class="paramname"><em>xf</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds all edges of given polyline that cross or touch given ball (center, radius) </p>

</div>
</div>
<a id="ga799578a1ff64417ca5aa5c72fa15bb2f" name="ga799578a1ff64417ca5aa5c72fa15bb2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga799578a1ff64417ca5aa5c72fa15bb2f">&#9670;&#160;</a></span>findEdgesInBall() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> void MR::findEdgesInBall </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceMR.html#a58b74f27c86e7e9dee889bfe30f3022a">Polyline3</a> &amp;&#160;</td>
          <td class="paramname"><em>polyline</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceMR.html#a5f4a954ba7d1785cafcb2f7ffe7acf09">Vector3f</a> &amp;&#160;</td>
          <td class="paramname"><em>center</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__AABBTreeGroup.html#gaf77c51a2927a660589bbe050fdbd6ac8">FoundEdgeCallback3</a> &amp;&#160;</td>
          <td class="paramname"><em>foundCallback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceMR.html#a9cf4b064aa13c5becce6312228c3c03b">AffineXf3f</a> *&#160;</td>
          <td class="paramname"><em>xf</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds all edges of given polyline that cross or touch given ball (center, radius) </p>

</div>
</div>
<a id="ga3672072155e3f272d13a40ccd4645d02" name="ga3672072155e3f272d13a40ccd4645d02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3672072155e3f272d13a40ccd4645d02">&#9670;&#160;</a></span>findMaxDistanceSq()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> float MR::findMaxDistanceSq </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structMR_1_1MeshPart.html">MeshPart</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structMR_1_1MeshPart.html">MeshPart</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceMR.html#a9cf4b064aa13c5becce6312228c3c03b">AffineXf3f</a> *&#160;</td>
          <td class="paramname"><em>rigidB2A</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>maxDistanceSq</em> = <code>FLT_MAX</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns the squared Hausdorff distance between two meshes, that is the maximum of squared distances from each mesh vertex to the other mesh (in both directions) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rigidB2A</td><td>rigid transformation from B-mesh space to A mesh space, nullptr considered as identity transformation </td></tr>
    <tr><td class="paramname">maxDistanceSq</td><td>upper limit on the positive distance in question, if the real distance is larger than the function exists returning maxDistanceSq </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga375d9c9dcfb1fd7d9a254a73370d71ba" name="ga375d9c9dcfb1fd7d9a254a73370d71ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga375d9c9dcfb1fd7d9a254a73370d71ba">&#9670;&#160;</a></span>findMaxDistanceSqOneWay()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> float MR::findMaxDistanceSqOneWay </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structMR_1_1MeshPart.html">MeshPart</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structMR_1_1MeshPart.html">MeshPart</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceMR.html#a9cf4b064aa13c5becce6312228c3c03b">AffineXf3f</a> *&#160;</td>
          <td class="paramname"><em>rigidB2A</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>maxDistanceSq</em> = <code>FLT_MAX</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns the maximum of the squared distances from each B-mesh vertex to A-mesh </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rigidB2A</td><td>rigid transformation from B-mesh space to A mesh space, nullptr considered as identity transformation </td></tr>
    <tr><td class="paramname">maxDistanceSq</td><td>upper limit on the positive distance in question, if the real distance is larger than the function exists returning maxDistanceSq </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga562052fddd56327be07ffe8c0cc7f7af" name="ga562052fddd56327be07ffe8c0cc7f7af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga562052fddd56327be07ffe8c0cc7f7af">&#9670;&#160;</a></span>findMaxVectorDim() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void MR::findMaxVectorDim </td>
          <td>(</td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>dimX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>dimY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structMR_1_1Vector2.html">Vector2</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>dir</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>finds index of maximum axis and stores it into dimY </p>
<p><a href="http://jcgt.org/published/0002/01/05/paper.pdf">http://jcgt.org/published/0002/01/05/paper.pdf</a> Example input: dir = (1,-2). Result: dimY = 1, dimX = 0. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">dimX</td><td>index of minimum axis </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dimY</td><td>index of maximum axis </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga7fcb33a674ea8b57ac858e40d42e26e3" name="ga7fcb33a674ea8b57ac858e40d42e26e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7fcb33a674ea8b57ac858e40d42e26e3">&#9670;&#160;</a></span>findMaxVectorDim() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void MR::findMaxVectorDim </td>
          <td>(</td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>dimX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>dimY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>dimZ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structMR_1_1Vector3.html">Vector3</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>dir</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>finds index of maximum axis and stores it into dimZ </p>
<p><a href="http://jcgt.org/published/0002/01/05/paper.pdf">http://jcgt.org/published/0002/01/05/paper.pdf</a> Example input: dir = (1,1,-2). Result: dimZ = 2, dimX = 1, dimY = 0. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">dimX</td><td>are filled by right-hand rule from dimZ </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dimY</td><td>are filled by right-hand rule from dimZ </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dimZ</td><td>index of maximum axis </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga50911249a881bd7365929503c138d8fa" name="ga50911249a881bd7365929503c138d8fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga50911249a881bd7365929503c138d8fa">&#9670;&#160;</a></span>findMeshEdgesInBall()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> void MR::findMeshEdgesInBall </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structMR_1_1Mesh.html">Mesh</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceMR.html#aef16e8bcd64e7d95e00ad05f1a333c43">AABBTreePolyline3</a> &amp;&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceMR.html#a5f4a954ba7d1785cafcb2f7ffe7acf09">Vector3f</a> &amp;&#160;</td>
          <td class="paramname"><em>center</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__AABBTreeGroup.html#gaf77c51a2927a660589bbe050fdbd6ac8">FoundEdgeCallback3</a> &amp;&#160;</td>
          <td class="paramname"><em>foundCallback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceMR.html#a9cf4b064aa13c5becce6312228c3c03b">AffineXf3f</a> *&#160;</td>
          <td class="paramname"><em>xf</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds all edges of given mesh edges (specified by the tree) that cross or touch given ball (center, radius) </p>

</div>
</div>
<a id="ga80e8bb354705c40373b5a8a3d1a3376c" name="ga80e8bb354705c40373b5a8a3d1a3376c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga80e8bb354705c40373b5a8a3d1a3376c">&#9670;&#160;</a></span>findPointsInBall() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> void MR::findPointsInBall </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMR_1_1AABBTreePoints.html">AABBTreePoints</a> &amp;&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceMR.html#a5f4a954ba7d1785cafcb2f7ffe7acf09">Vector3f</a> &amp;&#160;</td>
          <td class="paramname"><em>center</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceMR.html#ac4f1361c3362959c175d914a777b236d">FoundPointCallback</a> &amp;&#160;</td>
          <td class="paramname"><em>foundCallback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceMR.html#a9cf4b064aa13c5becce6312228c3c03b">AffineXf3f</a> *&#160;</td>
          <td class="paramname"><em>xf</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Finds all points in tree that are inside or on the surface of given ball (center, radius)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xf</td><td>points-to-center transformation, if not specified then identity transformation is assumed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga47bd19da135ff2a820eebd760da392a3" name="ga47bd19da135ff2a820eebd760da392a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga47bd19da135ff2a820eebd760da392a3">&#9670;&#160;</a></span>findPointsInBall() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> void MR::findPointsInBall </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structMR_1_1Mesh.html">Mesh</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceMR.html#a5f4a954ba7d1785cafcb2f7ffe7acf09">Vector3f</a> &amp;&#160;</td>
          <td class="paramname"><em>center</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceMR.html#ac4f1361c3362959c175d914a777b236d">FoundPointCallback</a> &amp;&#160;</td>
          <td class="paramname"><em>foundCallback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceMR.html#a9cf4b064aa13c5becce6312228c3c03b">AffineXf3f</a> *&#160;</td>
          <td class="paramname"><em>xf</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Finds all valid points of the mesh that are inside or on the surface of given ball (center, radius)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xf</td><td>points-to-center transformation, if not specified then identity transformation is assumed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga5c540a8264b2d4cd39a35ce8600e873e" name="ga5c540a8264b2d4cd39a35ce8600e873e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5c540a8264b2d4cd39a35ce8600e873e">&#9670;&#160;</a></span>findPointsInBall() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> void MR::findPointsInBall </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structMR_1_1PointCloud.html">PointCloud</a> &amp;&#160;</td>
          <td class="paramname"><em>pointCloud</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceMR.html#a5f4a954ba7d1785cafcb2f7ffe7acf09">Vector3f</a> &amp;&#160;</td>
          <td class="paramname"><em>center</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceMR.html#ac4f1361c3362959c175d914a777b236d">FoundPointCallback</a> &amp;&#160;</td>
          <td class="paramname"><em>foundCallback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceMR.html#a9cf4b064aa13c5becce6312228c3c03b">AffineXf3f</a> *&#160;</td>
          <td class="paramname"><em>xf</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Finds all valid points of pointCloud that are inside or on the surface of given ball (center, radius)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xf</td><td>points-to-center transformation, if not specified then identity transformation is assumed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaca9ee6c07f32374a18e511487904370b" name="gaca9ee6c07f32374a18e511487904370b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaca9ee6c07f32374a18e511487904370b">&#9670;&#160;</a></span>findProjection()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> <a class="el" href="structMR_1_1MeshProjectionResult.html">MeshProjectionResult</a> MR::findProjection </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceMR.html#a5f4a954ba7d1785cafcb2f7ffe7acf09">Vector3f</a> &amp;&#160;</td>
          <td class="paramname"><em>pt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structMR_1_1MeshPart.html">MeshPart</a> &amp;&#160;</td>
          <td class="paramname"><em>mp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>upDistLimitSq</em> = <code>FLT_MAX</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceMR.html#a9cf4b064aa13c5becce6312228c3c03b">AffineXf3f</a> *&#160;</td>
          <td class="paramname"><em>xf</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>loDistLimitSq</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceMR.html#a4234a65e90443b87f6412b4e681a38ac">FaceId</a>&#160;</td>
          <td class="paramname"><em>skipFace</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>computes the closest point on mesh (or its region) to given point </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">upDistLimitSq</td><td>upper limit on the distance in question, if the real distance is larger than the function exits returning upDistLimitSq and no valid point </td></tr>
    <tr><td class="paramname">xf</td><td>mesh-to-point transformation, if not specified then identity transformation is assumed </td></tr>
    <tr><td class="paramname">loDistLimitSq</td><td>low limit on the distance in question, if a point is found within this distance then it is immediately returned without searching for a closer one </td></tr>
    <tr><td class="paramname">skipFace</td><td>this triangle will be skipped and never returned as a projection </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaccdf7712b3c2bc175e4b09aae138aa40" name="gaccdf7712b3c2bc175e4b09aae138aa40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaccdf7712b3c2bc175e4b09aae138aa40">&#9670;&#160;</a></span>findProjectionOnMeshEdges() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> <a class="el" href="namespaceMR.html#a847af1551a9dcab4a5a333b6607522a7">PolylineProjectionResult3</a> MR::findProjectionOnMeshEdges </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceMR.html#acfd96aa6798933e1a002144fb0dc22af">Line3f</a> &amp;&#160;</td>
          <td class="paramname"><em>ln</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structMR_1_1Mesh.html">Mesh</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceMR.html#aef16e8bcd64e7d95e00ad05f1a333c43">AABBTreePolyline3</a> &amp;&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>upDistLimitSq</em> = <code>FLT_MAX</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceMR.html#a9cf4b064aa13c5becce6312228c3c03b">AffineXf3f</a> *&#160;</td>
          <td class="paramname"><em>xf</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>loDistLimitSq</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>computes the closest point on the mesh edges (specified by the tree) to given straight line </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">upDistLimitSq</td><td>upper limit on the distance in question, if the real distance is larger than the function exists returning upDistLimitSq and no valid point </td></tr>
    <tr><td class="paramname">xf</td><td>polyline-to-point transformation, if not specified then identity transformation is assumed </td></tr>
    <tr><td class="paramname">loDistLimitSq</td><td>low limit on the distance in question, if a point is found within this distance then it is immediately returned without searching for a closer one </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga64c37b9a7a04aa567390955a50891b57" name="ga64c37b9a7a04aa567390955a50891b57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga64c37b9a7a04aa567390955a50891b57">&#9670;&#160;</a></span>findProjectionOnMeshEdges() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> <a class="el" href="namespaceMR.html#a847af1551a9dcab4a5a333b6607522a7">PolylineProjectionResult3</a> MR::findProjectionOnMeshEdges </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceMR.html#a5f4a954ba7d1785cafcb2f7ffe7acf09">Vector3f</a> &amp;&#160;</td>
          <td class="paramname"><em>pt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structMR_1_1Mesh.html">Mesh</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceMR.html#aef16e8bcd64e7d95e00ad05f1a333c43">AABBTreePolyline3</a> &amp;&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>upDistLimitSq</em> = <code>FLT_MAX</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceMR.html#a9cf4b064aa13c5becce6312228c3c03b">AffineXf3f</a> *&#160;</td>
          <td class="paramname"><em>xf</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>loDistLimitSq</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>computes the closest point on the mesh edges (specified by the tree) to given point </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">upDistLimitSq</td><td>upper limit on the distance in question, if the real distance is larger than the function exists returning upDistLimitSq and no valid point </td></tr>
    <tr><td class="paramname">xf</td><td>polyline-to-point transformation, if not specified then identity transformation is assumed </td></tr>
    <tr><td class="paramname">loDistLimitSq</td><td>low limit on the distance in question, if a point is found within this distance then it is immediately returned without searching for a closer one </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga91f4a4e75eedf94f3028f574f0028dfb" name="ga91f4a4e75eedf94f3028f574f0028dfb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga91f4a4e75eedf94f3028f574f0028dfb">&#9670;&#160;</a></span>findProjectionOnPoints()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> <a class="el" href="structMR_1_1PointsProjectionResult.html">PointsProjectionResult</a> MR::findProjectionOnPoints </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceMR.html#a5f4a954ba7d1785cafcb2f7ffe7acf09">Vector3f</a> &amp;&#160;</td>
          <td class="paramname"><em>pt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structMR_1_1PointCloud.html">PointCloud</a> &amp;&#160;</td>
          <td class="paramname"><em>pc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>upDistLimitSq</em> = <code>FLT_MAX</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceMR.html#a9cf4b064aa13c5becce6312228c3c03b">AffineXf3f</a> *&#160;</td>
          <td class="paramname"><em>xf</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>loDistLimitSq</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>computes the closest point on point cloud to given point </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">upDistLimitSq</td><td>upper limit on the distance in question, if the real distance is larger than the function exits returning upDistLimitSq and no valid point </td></tr>
    <tr><td class="paramname">xf</td><td>pointcloud-to-point transformation, if not specified then identity transformation is assumed </td></tr>
    <tr><td class="paramname">loDistLimitSq</td><td>low limit on the distance in question, if a point is found within this distance then it is immediately returned without searching for a closer one </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaa484a0628a7ac3858cd590589687141c" name="gaa484a0628a7ac3858cd590589687141c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa484a0628a7ac3858cd590589687141c">&#9670;&#160;</a></span>findProjectionOnPolyline() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> <a class="el" href="namespaceMR.html#a847af1551a9dcab4a5a333b6607522a7">PolylineProjectionResult3</a> MR::findProjectionOnPolyline </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceMR.html#acfd96aa6798933e1a002144fb0dc22af">Line3f</a> &amp;&#160;</td>
          <td class="paramname"><em>ln</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceMR.html#a58b74f27c86e7e9dee889bfe30f3022a">Polyline3</a> &amp;&#160;</td>
          <td class="paramname"><em>polyline</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>upDistLimitSq</em> = <code>FLT_MAX</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceMR.html#a9cf4b064aa13c5becce6312228c3c03b">AffineXf3f</a> *&#160;</td>
          <td class="paramname"><em>xf</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>loDistLimitSq</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>computes the closest point on polyline to given straight line </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">upDistLimitSq</td><td>upper limit on the distance in question, if the real distance is larger than the function exists returning upDistLimitSq and no valid point </td></tr>
    <tr><td class="paramname">xf</td><td>polyline-to-point transformation, if not specified then identity transformation is assumed </td></tr>
    <tr><td class="paramname">loDistLimitSq</td><td>low limit on the distance in question, if a point is found within this distance then it is immediately returned without searching for a closer one </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga5e71a300face382a26ba8596d9b19820" name="ga5e71a300face382a26ba8596d9b19820"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5e71a300face382a26ba8596d9b19820">&#9670;&#160;</a></span>findProjectionOnPolyline() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> <a class="el" href="namespaceMR.html#a847af1551a9dcab4a5a333b6607522a7">PolylineProjectionResult3</a> MR::findProjectionOnPolyline </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceMR.html#a5f4a954ba7d1785cafcb2f7ffe7acf09">Vector3f</a> &amp;&#160;</td>
          <td class="paramname"><em>pt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceMR.html#a58b74f27c86e7e9dee889bfe30f3022a">Polyline3</a> &amp;&#160;</td>
          <td class="paramname"><em>polyline</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>upDistLimitSq</em> = <code>FLT_MAX</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceMR.html#a9cf4b064aa13c5becce6312228c3c03b">AffineXf3f</a> *&#160;</td>
          <td class="paramname"><em>xf</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>loDistLimitSq</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>computes the closest point on polyline to given point </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">upDistLimitSq</td><td>upper limit on the distance in question, if the real distance is larger than the function exists returning upDistLimitSq and no valid point </td></tr>
    <tr><td class="paramname">xf</td><td>polyline-to-point transformation, if not specified then identity transformation is assumed </td></tr>
    <tr><td class="paramname">loDistLimitSq</td><td>low limit on the distance in question, if a point is found within this distance then it is immediately returned without searching for a closer one </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga7f7211a85409018fd8ee71495646faa3" name="ga7f7211a85409018fd8ee71495646faa3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7f7211a85409018fd8ee71495646faa3">&#9670;&#160;</a></span>findProjectionOnPolyline2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> <a class="el" href="namespaceMR.html#a0898ca7d08b2fb73875b21bf4921f4fd">PolylineProjectionResult2</a> MR::findProjectionOnPolyline2 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceMR.html#a61594f31bab4ef06a3f164c0199198e7">Vector2f</a> &amp;&#160;</td>
          <td class="paramname"><em>pt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceMR.html#ab1ca9892644603a8b29005353e5ada79">Polyline2</a> &amp;&#160;</td>
          <td class="paramname"><em>polyline</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>upDistLimitSq</em> = <code>FLT_MAX</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceMR.html#aaf5a1eb99830c5d7196aa5bf3a05f70e">AffineXf2f</a> *&#160;</td>
          <td class="paramname"><em>xf</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>loDistLimitSq</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>computes the closest point on polyline to given point </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">upDistLimitSq</td><td>upper limit on the distance in question, if the real distance is larger than the function exists returning upDistLimitSq and no valid point </td></tr>
    <tr><td class="paramname">xf</td><td>polyline-to-point transformation, if not specified then identity transformation is assumed </td></tr>
    <tr><td class="paramname">loDistLimitSq</td><td>low limit on the distance in question, if a point is found within this distance then it is immediately returned without searching for a closer one </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf2ef419d4414bb6d0efa0c918b21bddf" name="gaf2ef419d4414bb6d0efa0c918b21bddf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf2ef419d4414bb6d0efa0c918b21bddf">&#9670;&#160;</a></span>findProjectionOnPolyline2WithOffset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> <a class="el" href="namespaceMR.html#aa9c24bbb5a16bcc2d1385bdbd2340aae">Polyline2ProjectionWithOffsetResult</a> MR::findProjectionOnPolyline2WithOffset </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceMR.html#a61594f31bab4ef06a3f164c0199198e7">Vector2f</a> &amp;&#160;</td>
          <td class="paramname"><em>pt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceMR.html#ab1ca9892644603a8b29005353e5ada79">Polyline2</a> &amp;&#160;</td>
          <td class="paramname"><em>polyline</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMR_1_1Vector.html">Vector</a>&lt; float, <a class="el" href="namespaceMR.html#a65798dca01178b50da3bbd7968fb360e">UndirectedEdgeId</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>offsetPerEdge</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>upDistLimit</em> = <code>FLT_MAX</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceMR.html#aaf5a1eb99830c5d7196aa5bf3a05f70e">AffineXf2f</a> *&#160;</td>
          <td class="paramname"><em>xf</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>loDistLimit</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>computes the closest point on polyline to given point, respecting each edge offset </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">offsetPerEdge</td><td>offset for each edge of polyline </td></tr>
    <tr><td class="paramname">upDistLimit</td><td>upper limit on the distance in question, if the real distance is larger than the function exists returning upDistLimit and no valid point </td></tr>
    <tr><td class="paramname">xf</td><td>polyline-to-point transformation, if not specified then identity transformation is assumed </td></tr>
    <tr><td class="paramname">loDistLimit</td><td>low limit on the distance in question, if a point is found within this distance then it is immediately returned without searching for a closer one </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga834d7e50b54b1b8c511990fc9d14c09c" name="ga834d7e50b54b1b8c511990fc9d14c09c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga834d7e50b54b1b8c511990fc9d14c09c">&#9670;&#160;</a></span>findProjectionOnPolylineWithOffset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> <a class="el" href="namespaceMR.html#a2488a5918dcbf78bcbf511ea6c93a185">PolylineProjectionWithOffsetResult3</a> MR::findProjectionOnPolylineWithOffset </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceMR.html#a5f4a954ba7d1785cafcb2f7ffe7acf09">Vector3f</a> &amp;&#160;</td>
          <td class="paramname"><em>pt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceMR.html#a58b74f27c86e7e9dee889bfe30f3022a">Polyline3</a> &amp;&#160;</td>
          <td class="paramname"><em>polyline</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMR_1_1Vector.html">Vector</a>&lt; float, <a class="el" href="namespaceMR.html#a65798dca01178b50da3bbd7968fb360e">UndirectedEdgeId</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>offsetPerEdge</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>upDistLimit</em> = <code>FLT_MAX</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceMR.html#a9cf4b064aa13c5becce6312228c3c03b">AffineXf3f</a> *&#160;</td>
          <td class="paramname"><em>xf</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>loDistLimit</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>computes the closest point on polyline to given point, respecting each edge offset </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">offsetPerEdge</td><td>offset for each edge of polyline </td></tr>
    <tr><td class="paramname">upDistLimit</td><td>upper limit on the distance in question, if the real distance is larger than the function exists returning upDistLimit and no valid point </td></tr>
    <tr><td class="paramname">xf</td><td>polyline-to-point transformation, if not specified then identity transformation is assumed </td></tr>
    <tr><td class="paramname">loDistLimit</td><td>low limit on the distance in question, if a point is found within this distance then it is immediately returned without searching for a closer one </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga4fca223a68dac564f66af0224c0ec3ec" name="ga4fca223a68dac564f66af0224c0ec3ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4fca223a68dac564f66af0224c0ec3ec">&#9670;&#160;</a></span>findSelfCollidingEdgePairs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> std::vector&lt; <a class="el" href="structMR_1_1EdgePointPair.html">EdgePointPair</a> &gt; MR::findSelfCollidingEdgePairs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceMR.html#ab1ca9892644603a8b29005353e5ada79">Polyline2</a> &amp;&#160;</td>
          <td class="paramname"><em>polyline</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>finds all pairs of colliding edges from 2d polyline </p>

</div>
</div>
<a id="gad89aed99c2cba4cd08e06d896b839841" name="gad89aed99c2cba4cd08e06d896b839841"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad89aed99c2cba4cd08e06d896b839841">&#9670;&#160;</a></span>findSelfCollidingEdges()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> std::vector&lt; <a class="el" href="structMR_1_1UndirectedEdgeUndirectedEdge.html">UndirectedEdgeUndirectedEdge</a> &gt; MR::findSelfCollidingEdges </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceMR.html#ab1ca9892644603a8b29005353e5ada79">Polyline2</a> &amp;&#160;</td>
          <td class="paramname"><em>polyline</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>finds all pairs of colliding edges from 2d polyline </p>

</div>
</div>
<a id="ga8658f18b6b0489c1dafa4903c64c0165" name="ga8658f18b6b0489c1dafa4903c64c0165"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8658f18b6b0489c1dafa4903c64c0165">&#9670;&#160;</a></span>findSelfCollidingEdgesBS()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> <a class="el" href="namespaceMR.html#ae5a4467feb7b60cd337643529597aaaa">UndirectedEdgeBitSet</a> MR::findSelfCollidingEdgesBS </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceMR.html#ab1ca9892644603a8b29005353e5ada79">Polyline2</a> &amp;&#160;</td>
          <td class="paramname"><em>polyline</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>finds the union of all self-intersecting edges </p>

</div>
</div>
<a id="ga6d98c0d3c3c6ee98a1cea7662a3f704f" name="ga6d98c0d3c3c6ee98a1cea7662a3f704f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6d98c0d3c3c6ee98a1cea7662a3f704f">&#9670;&#160;</a></span>findSelfCollidingTriangles()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> <a class="el" href="namespaceMR.html#a9e4cb12e0805ba24e046ac622cdc33bb">Expected</a>&lt; std::vector&lt; <a class="el" href="structMR_1_1FaceFace.html">FaceFace</a> &gt;, std::string &gt; MR::findSelfCollidingTriangles </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structMR_1_1MeshPart.html">MeshPart</a> &amp;&#160;</td>
          <td class="paramname"><em>mp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__BasicStructuresGroup.html#ga51ff94746a41880cd06d3272b5bcf710">ProgressCallback</a>&#160;</td>
          <td class="paramname"><em>cb</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>finds all pairs of colliding triangles from one mesh or a region </p>

</div>
</div>
<a id="ga0268cc5d3075529584b5c17df4c22243" name="ga0268cc5d3075529584b5c17df4c22243"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0268cc5d3075529584b5c17df4c22243">&#9670;&#160;</a></span>findSelfCollidingTrianglesBS()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> <a class="el" href="namespaceMR.html#a9e4cb12e0805ba24e046ac622cdc33bb">Expected</a>&lt; <a class="el" href="namespaceMR.html#a0e5b61f8edf7a896c3f2f4a6eeb4691d">FaceBitSet</a>, std::string &gt; MR::findSelfCollidingTrianglesBS </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structMR_1_1MeshPart.html">MeshPart</a> &amp;&#160;</td>
          <td class="paramname"><em>mp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__BasicStructuresGroup.html#ga51ff94746a41880cd06d3272b5bcf710">ProgressCallback</a>&#160;</td>
          <td class="paramname"><em>cb</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>the same <a class="el" href="group__AABBTreeGroup.html#ga6d98c0d3c3c6ee98a1cea7662a3f704f">findSelfCollidingTriangles</a> but returns the union of all self-intersecting faces </p>

</div>
</div>
<a id="ga66ee7b0ec534fcfe70ef96f8f3d3b545" name="ga66ee7b0ec534fcfe70ef96f8f3d3b545"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga66ee7b0ec534fcfe70ef96f8f3d3b545">&#9670;&#160;</a></span>findSignedDistance() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> <a class="el" href="structMR_1_1MeshSignedDistanceResult.html">MeshSignedDistanceResult</a> MR::findSignedDistance </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structMR_1_1MeshPart.html">MeshPart</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structMR_1_1MeshPart.html">MeshPart</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceMR.html#a9cf4b064aa13c5becce6312228c3c03b">AffineXf3f</a> *&#160;</td>
          <td class="paramname"><em>rigidB2A</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>upDistLimitSq</em> = <code>FLT_MAX</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>computes minimal distance between two meshes </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rigidB2A</td><td>rigid transformation from B-mesh space to A mesh space, nullptr considered as identity transformation </td></tr>
    <tr><td class="paramname">upDistLimitSq</td><td>upper limit on the positive distance in question, if the real distance is larger than the function exists returning upDistLimitSq and no valid points </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga44d0cb5151cae38d27130277c50301bc" name="ga44d0cb5151cae38d27130277c50301bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga44d0cb5151cae38d27130277c50301bc">&#9670;&#160;</a></span>findSignedDistance() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> std::optional&lt; <a class="el" href="structMR_1_1SignedDistanceToMeshResult.html">SignedDistanceToMeshResult</a> &gt; MR::findSignedDistance </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceMR.html#a5f4a954ba7d1785cafcb2f7ffe7acf09">Vector3f</a> &amp;&#160;</td>
          <td class="paramname"><em>pt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structMR_1_1MeshPart.html">MeshPart</a> &amp;&#160;</td>
          <td class="paramname"><em>mp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>upDistLimitSq</em> = <code>FLT_MAX</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>loDistLimitSq</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>computes the closest point on mesh (or its region) to given point, and finds the distance with sign to it (positive - outside, negative - inside the mesh) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">upDistLimitSq</td><td>upper limit on the distance in question, if the real distance is larger then the function exits returning nullopt </td></tr>
    <tr><td class="paramname">loDistLimitSq</td><td>low limit on the distance in question, if the real distance smaller then the function exits returning nullopt </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga3c1bb6417aaa769fa4156f2edac91749" name="ga3c1bb6417aaa769fa4156f2edac91749"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3c1bb6417aaa769fa4156f2edac91749">&#9670;&#160;</a></span>getNumNodes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int MR::getNumNodes </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numLeaves</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns the number of nodes in the binary tree with given number of leaves </p>

</div>
</div>
<a id="ga2096ace9292b40c55421517434fd8bd8" name="ga2096ace9292b40c55421517434fd8bd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2096ace9292b40c55421517434fd8bd8">&#9670;&#160;</a></span>getToFloatConverter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> <a class="el" href="group__AABBTreeGroup.html#ga4835cdcf7f575fd6b4381c29fc920269">ConvertToFloatVector</a> MR::getToFloatConverter </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceMR.html#a438e80434fdd3ef1a3d09e32a3d593d5">Box3d</a> &amp;&#160;</td>
          <td class="paramname"><em>box</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>creates converter from Vector3i to Vector3f in <a class="el" href="structMR_1_1Box.html" title="Box given by its min- and max- corners.">Box</a> range (int diapason is mapped to box range) </p>

</div>
</div>
<a id="ga9736a434a7f001c05b9a7d23675ca257" name="ga9736a434a7f001c05b9a7d23675ca257"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9736a434a7f001c05b9a7d23675ca257">&#9670;&#160;</a></span>getToIntConverter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> <a class="el" href="group__AABBTreeGroup.html#gaa1341f2eec34b89f628200697d1c55a1">ConvertToIntVector</a> MR::getToIntConverter </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceMR.html#a438e80434fdd3ef1a3d09e32a3d593d5">Box3d</a> &amp;&#160;</td>
          <td class="paramname"><em>box</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>creates converter from Vector3f to Vector3i in <a class="el" href="structMR_1_1Box.html" title="Box given by its min- and max- corners.">Box</a> range (int diapason is mapped to box range) </p>

</div>
</div>
<a id="ga125d7b99c7b4840e87a3470ef0c64b17" name="ga125d7b99c7b4840e87a3470ef0c64b17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga125d7b99c7b4840e87a3470ef0c64b17">&#9670;&#160;</a></span>getVectorConverters()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> <a class="el" href="structMR_1_1CoordinateConverters.html">CoordinateConverters</a> MR::getVectorConverters </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structMR_1_1MeshPart.html">MeshPart</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structMR_1_1MeshPart.html">MeshPart</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceMR.html#a9cf4b064aa13c5becce6312228c3c03b">AffineXf3f</a> *&#160;</td>
          <td class="paramname"><em>rigidB2A</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>creates simple converters from Vector3f to Vector3i and back in mesh parts area range </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rigidB2A</td><td>rigid transformation from B-mesh space to A mesh space, nullptr considered as identity transformation </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga9984ed4cff38cd012243e835f02e0e92" name="ga9984ed4cff38cd012243e835f02e0e92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9984ed4cff38cd012243e835f02e0e92">&#9670;&#160;</a></span>IntersectionPrecomputes() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structMR_1_1IntersectionPrecomputes.html">MR::IntersectionPrecomputes</a>&lt; T &gt;::IntersectionPrecomputes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="gac2a5a2178c875139ca3e402c1a46324c" name="gac2a5a2178c875139ca3e402c1a46324c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac2a5a2178c875139ca3e402c1a46324c">&#9670;&#160;</a></span>IntersectionPrecomputes() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structMR_1_1IntersectionPrecomputes.html">MR::IntersectionPrecomputes</a>&lt; T &gt;::IntersectionPrecomputes </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structMR_1_1Vector3.html">Vector3</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>dir</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ga3c4d304b28fd4695d20dc454318f5660" name="ga3c4d304b28fd4695d20dc454318f5660"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3c4d304b28fd4695d20dc454318f5660">&#9670;&#160;</a></span>isInside() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> bool MR::isInside </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structMR_1_1MeshPart.html">MeshPart</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structMR_1_1MeshPart.html">MeshPart</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceMR.html#a9cf4b064aa13c5becce6312228c3c03b">AffineXf3f</a> *&#160;</td>
          <td class="paramname"><em>rigidB2A</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>checks that arbitrary mesh part A is inside of closed mesh part B </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rigidB2A</td><td>rigid transformation from B-mesh space to A mesh space, nullptr considered as identity transformation </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaa8d770560279dcdaa48764810b77c30d" name="gaa8d770560279dcdaa48764810b77c30d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa8d770560279dcdaa48764810b77c30d">&#9670;&#160;</a></span>isInside() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> bool MR::isInside </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceMR.html#ab1ca9892644603a8b29005353e5ada79">Polyline2</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceMR.html#ab1ca9892644603a8b29005353e5ada79">Polyline2</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceMR.html#aaf5a1eb99830c5d7196aa5bf3a05f70e">AffineXf2f</a> *&#160;</td>
          <td class="paramname"><em>rigidB2A</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>checks that arbitrary 2d polyline A is inside of closed 2d polyline B </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rigidB2A</td><td>rigid transformation from B-polyline space to A polyline space, nullptr considered as identity transformation </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga30d53ebf69ce150861f17e4695543778" name="ga30d53ebf69ce150861f17e4695543778"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga30d53ebf69ce150861f17e4695543778">&#9670;&#160;</a></span>isNonIntersectingInside()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> bool MR::isNonIntersectingInside </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structMR_1_1MeshPart.html">MeshPart</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structMR_1_1MeshPart.html">MeshPart</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceMR.html#a9cf4b064aa13c5becce6312228c3c03b">AffineXf3f</a> *&#160;</td>
          <td class="paramname"><em>rigidB2A</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>checks that arbitrary mesh part A is inside of closed mesh part B The version of <code>isInside</code> without collision check; it is user's responsibility to guarantee that the meshes don't collide </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rigidB2A</td><td>rigid transformation from B-mesh space to A mesh space, nullptr considered as identity transformation </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga2aba3040bbdbbafb7d8e38803b955524" name="ga2aba3040bbdbbafb7d8e38803b955524"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2aba3040bbdbbafb7d8e38803b955524">&#9670;&#160;</a></span>isPointInsidePolyline()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> bool MR::isPointInsidePolyline </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceMR.html#ab1ca9892644603a8b29005353e5ada79">Polyline2</a> &amp;&#160;</td>
          <td class="paramname"><em>polyline</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceMR.html#a61594f31bab4ef06a3f164c0199198e7">Vector2f</a> &amp;&#160;</td>
          <td class="paramname"><em>point</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>detect if given point is inside polyline, by counting ray intersections </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">polyline</td><td>input polyline </td></tr>
    <tr><td class="paramname">point</td><td>input point </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga364302ddaf673e7f00c6745f4172d6c0" name="ga364302ddaf673e7f00c6745f4172d6c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga364302ddaf673e7f00c6745f4172d6c0">&#9670;&#160;</a></span>makeAABBTreeNodeVec()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__AABBTreeGroup.html#ga0dc29c20db23419ffc06b5a3a0244204">AABBTreeNodeVec</a>&lt; T &gt; MR::makeAABBTreeNodeVec </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMR_1_1Buffer.html">Buffer</a>&lt; <a class="el" href="structMR_1_1BoxedLeaf.html">BoxedLeaf</a>&lt; T &gt; &gt;&#160;</td>
          <td class="paramname"><em>boxedLeaves</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga8f7cfd40975f9648e9785f72d75ff92d" name="ga8f7cfd40975f9648e9785f72d75ff92d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8f7cfd40975f9648e9785f72d75ff92d">&#9670;&#160;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool MR::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structMR_1_1EdgeTri.html">EdgeTri</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structMR_1_1EdgeTri.html">EdgeTri</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="gadb20234daa82631954c44c1676424e5f" name="gadb20234daa82631954c44c1676424e5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadb20234daa82631954c44c1676424e5f">&#9670;&#160;</a></span>processCloseTriangles()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> void MR::processCloseTriangles </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structMR_1_1MeshPart.html">MeshPart</a> &amp;&#160;</td>
          <td class="paramname"><em>mp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceMR.html#a34931e18c46a0007ca98d04847051247">Triangle3f</a> &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>rangeSq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__AABBTreeGroup.html#ga163d12cc5f6452ebe26a959afb1d5379">TriangleCallback</a> &amp;&#160;</td>
          <td class="paramname"><em>call</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>invokes given callback for all triangles from given mesh part located not further than given squared distance from t-triangle </p>

</div>
</div>
<a id="ga046de9351673df9583898d31c01e297c" name="ga046de9351673df9583898d31c01e297c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga046de9351673df9583898d31c01e297c">&#9670;&#160;</a></span>rayMeshIntersect() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> std::optional&lt; <a class="el" href="structMR_1_1MeshIntersectionResult.html">MeshIntersectionResult</a> &gt; MR::rayMeshIntersect </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structMR_1_1MeshPart.html">MeshPart</a> &amp;&#160;</td>
          <td class="paramname"><em>meshPart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceMR.html#ad78dde2996d3a2b85bb7fd22db18efb6">Line3d</a> &amp;&#160;</td>
          <td class="paramname"><em>line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>rayStart</em> = <code>0.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>rayEnd</em> = <code>DBL_MAX</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structMR_1_1IntersectionPrecomputes.html">IntersectionPrecomputes</a>&lt; double &gt; *&#160;</td>
          <td class="paramname"><em>prec</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>closestIntersect</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Finds ray and mesh intersection in double-precision. <code>rayStart</code> and <code>rayEnd</code> define the interval on the ray to detect an intersection. <code>prec</code> can be specified to reuse some precomputations (e.g. for checking many parallel rays). Finds the closest to ray origin intersection (or any intersection for better performance if <code>!closestIntersect</code>). </p>

</div>
</div>
<a id="gabc0eec956303a3e852dd8f7e07f55d12" name="gabc0eec956303a3e852dd8f7e07f55d12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabc0eec956303a3e852dd8f7e07f55d12">&#9670;&#160;</a></span>rayMeshIntersect() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> std::optional&lt; <a class="el" href="structMR_1_1MeshIntersectionResult.html">MeshIntersectionResult</a> &gt; MR::rayMeshIntersect </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structMR_1_1MeshPart.html">MeshPart</a> &amp;&#160;</td>
          <td class="paramname"><em>meshPart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceMR.html#acfd96aa6798933e1a002144fb0dc22af">Line3f</a> &amp;&#160;</td>
          <td class="paramname"><em>line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>rayStart</em> = <code>0.0f</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>rayEnd</em> = <code>FLT_MAX</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structMR_1_1IntersectionPrecomputes.html">IntersectionPrecomputes</a>&lt; float &gt; *&#160;</td>
          <td class="paramname"><em>prec</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>closestIntersect</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Finds ray and mesh intersection in float-precision. <code>rayStart</code> and <code>rayEnd</code> define the interval on the ray to detect an intersection. <code>prec</code> can be specified to reuse some precomputations (e.g. for checking many parallel rays). Finds the closest to ray origin intersection (or any intersection for better performance if <code>!closestIntersect</code>). </p>

</div>
</div>
<a id="ga4f7fec7775a22ca743ad08d9b8ae3056" name="ga4f7fec7775a22ca743ad08d9b8ae3056"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4f7fec7775a22ca743ad08d9b8ae3056">&#9670;&#160;</a></span>rayMeshIntersectAll() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> void MR::rayMeshIntersectAll </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structMR_1_1MeshPart.html">MeshPart</a> &amp;&#160;</td>
          <td class="paramname"><em>meshPart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceMR.html#ad78dde2996d3a2b85bb7fd22db18efb6">Line3d</a> &amp;&#160;</td>
          <td class="paramname"><em>line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__AABBTreeGroup.html#gab84b0b767274335b6f0f59bbb9537fe3">MeshIntersectionCallback</a>&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>rayStart</em> = <code>0.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>rayEnd</em> = <code>DBL_MAX</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structMR_1_1IntersectionPrecomputes.html">IntersectionPrecomputes</a>&lt; double &gt; *&#160;</td>
          <td class="paramname"><em>prec</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Same as <a class="el" href="group__AABBTreeGroup.html#rayMeshIntersectAllF">rayMeshIntersectAllF</a>, but use double precision. </p>

</div>
</div>
<a id="gac978c520f500c1e3dad2ddaff7a333f0" name="gac978c520f500c1e3dad2ddaff7a333f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac978c520f500c1e3dad2ddaff7a333f0">&#9670;&#160;</a></span>rayMeshIntersectAll() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> void MR::rayMeshIntersectAll </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structMR_1_1MeshPart.html">MeshPart</a> &amp;&#160;</td>
          <td class="paramname"><em>meshPart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceMR.html#acfd96aa6798933e1a002144fb0dc22af">Line3f</a> &amp;&#160;</td>
          <td class="paramname"><em>line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__AABBTreeGroup.html#gab84b0b767274335b6f0f59bbb9537fe3">MeshIntersectionCallback</a>&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>rayStart</em> = <code>0.0f</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>rayEnd</em> = <code>FLT_MAX</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structMR_1_1IntersectionPrecomputes.html">IntersectionPrecomputes</a>&lt; float &gt; *&#160;</td>
          <td class="paramname"><em>prec</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Intersects ray with mesh. Finds all intersections <a class="anchor" id="rayMeshIntersectAllF"></a> </p>

</div>
</div>
<a id="ga240b42f542774e3965806c916ba298ba" name="ga240b42f542774e3965806c916ba298ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga240b42f542774e3965806c916ba298ba">&#9670;&#160;</a></span>rayMultiMeshAnyIntersect() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> std::optional&lt; <a class="el" href="structMR_1_1MultiMeshIntersectionResult.html">MultiMeshIntersectionResult</a> &gt; MR::rayMultiMeshAnyIntersect </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="group__AABBTreeGroup.html#gaaf317c41824870416408c08346c2171e">Line3dMesh</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>lineMeshes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>rayStart</em> = <code>0.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>rayEnd</em> = <code>DBL_MAX</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Same as <a class="el" href="group__AABBTreeGroup.html#rayMultiMeshAnyIntersectF">rayMultiMeshAnyIntersectF</a>, but use double precision. </p>

</div>
</div>
<a id="ga541656ec925c37fde32a91a25444e35f" name="ga541656ec925c37fde32a91a25444e35f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga541656ec925c37fde32a91a25444e35f">&#9670;&#160;</a></span>rayMultiMeshAnyIntersect() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> std::optional&lt; <a class="el" href="structMR_1_1MultiMeshIntersectionResult.html">MultiMeshIntersectionResult</a> &gt; MR::rayMultiMeshAnyIntersect </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="group__AABBTreeGroup.html#ga5ab271790117f87421a1332a6c3e9d95">Line3fMesh</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>lineMeshes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>rayStart</em> = <code>0.0f</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>rayEnd</em> = <code>FLT_MAX</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Intersects ray with many meshes. Finds any intersection (not the closest) <a class="anchor" id="rayMultiMeshAnyIntersectF"></a> </p>

</div>
</div>
<a id="ga881bc4cb6ab7f415bf85d9235e2ca740" name="ga881bc4cb6ab7f415bf85d9235e2ca740"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga881bc4cb6ab7f415bf85d9235e2ca740">&#9670;&#160;</a></span>xyPlaneMeshIntersect()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> void MR::xyPlaneMeshIntersect </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structMR_1_1MeshPart.html">MeshPart</a> &amp;&#160;</td>
          <td class="paramname"><em>meshPart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>zLevel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceMR.html#a0e5b61f8edf7a896c3f2f4a6eeb4691d">FaceBitSet</a> *&#160;</td>
          <td class="paramname"><em>fs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceMR.html#ae5a4467feb7b60cd337643529597aaaa">UndirectedEdgeBitSet</a> *&#160;</td>
          <td class="paramname"><em>ues</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceMR.html#ab615a9e54d407017abd63d056ce4be66">VertBitSet</a> *&#160;</td>
          <td class="paramname"><em>vs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>given mesh part and plane z=zLevel, outputs </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fs</td><td>triangles crossed or touched by the plane </td></tr>
    <tr><td class="paramname">ues</td><td>edges of these triangles </td></tr>
    <tr><td class="paramname">vs</td><td>vertices of these triangles </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="ga59240ce19dcf5b27221a347b22086fcb" name="ga59240ce19dcf5b27221a347b22086fcb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga59240ce19dcf5b27221a347b22086fcb">&#9670;&#160;</a></span>idxX</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="structMR_1_1IntersectionPrecomputes.html">MR::IntersectionPrecomputes</a>&lt; T &gt;::idxX = 0</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga1e89bb11cf7c4693e1c8839963994a08" name="ga1e89bb11cf7c4693e1c8839963994a08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1e89bb11cf7c4693e1c8839963994a08">&#9670;&#160;</a></span>idxY</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="structMR_1_1IntersectionPrecomputes.html">MR::IntersectionPrecomputes</a>&lt; T &gt;::idxY = 1</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga5e3f58e5a000086f4df8523da65c9b4f" name="ga5e3f58e5a000086f4df8523da65c9b4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5e3f58e5a000086f4df8523da65c9b4f">&#9670;&#160;</a></span>invDir</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structMR_1_1Vector3.html">Vector3</a>&lt;T&gt; <a class="el" href="structMR_1_1IntersectionPrecomputes.html">MR::IntersectionPrecomputes</a>&lt; T &gt;::invDir</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="gaffa5bcb7a516c4dda421ace86e2597c2" name="gaffa5bcb7a516c4dda421ace86e2597c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaffa5bcb7a516c4dda421ace86e2597c2">&#9670;&#160;</a></span>maxDimIdxZ</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="structMR_1_1IntersectionPrecomputes.html">MR::IntersectionPrecomputes</a>&lt; T &gt;::maxDimIdxZ = 2</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga28372a635ba67b43220bc9067be6560d" name="ga28372a635ba67b43220bc9067be6560d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga28372a635ba67b43220bc9067be6560d">&#9670;&#160;</a></span>sign</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceMR.html#af24b71b1cf7ac2e3a63c2d988fd599f0">Vector3i</a> <a class="el" href="structMR_1_1IntersectionPrecomputes.html">MR::IntersectionPrecomputes</a>&lt; T &gt;::sign</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>stores signs of direction vector; </p>

</div>
</div>
<a id="ga21465bc7d67177777744f39ac171940c" name="ga21465bc7d67177777744f39ac171940c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga21465bc7d67177777744f39ac171940c">&#9670;&#160;</a></span>Sx</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="structMR_1_1IntersectionPrecomputes.html">MR::IntersectionPrecomputes</a>&lt; T &gt;::Sx</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>precomputed factors </p>

</div>
</div>
<a id="gaf95502c89221bba3187782d4ed18199b" name="gaf95502c89221bba3187782d4ed18199b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf95502c89221bba3187782d4ed18199b">&#9670;&#160;</a></span>Sy</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="structMR_1_1IntersectionPrecomputes.html">MR::IntersectionPrecomputes</a>&lt; T &gt;::Sy</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga6159c869b0afc38ccf26091c1681194a" name="ga6159c869b0afc38ccf26091c1681194a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6159c869b0afc38ccf26091c1681194a">&#9670;&#160;</a></span>Sz</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="structMR_1_1IntersectionPrecomputes.html">MR::IntersectionPrecomputes</a>&lt; T &gt;::Sz</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.7 </li>
  </ul>
</div>
</body>
</html>
